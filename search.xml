<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Load 方法 暨 程序的加载顺序]]></title>
      <url>http://lionwy.github.io/Load-%E6%96%B9%E6%B3%95-%E6%9A%A8-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><img src="http://oeb4c30x3.bkt.clouddn.com/20170226193145_W6qoAJ_luis-llerena-14739.jpeg" alt=""></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，App 的入口是 <code>main</code> 函数，而在此之前，我们了解到的是系统会自动调用 <code>load</code> 方法。而且是先调用父类的，再是自己的，最后才是分类的。而为什么是这样呢，不清楚。<br>下面所有的 <code>load</code> 方法， 都指 <code>+ (void)load {}</code> 方法。</p>
<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>借助于<a href="https://github.com/isaacselement/objc4-706" target="_blank" rel="external">可调试的 objc 源码</a> 了解了 <code>load</code> 方法的具体流程。</p>
<ol>
<li><p>创建一个类 <code>XXObject</code>，新建一个 <code>load</code> 方法，打断点，调用栈显示，引出了 <code>dyld</code> 和 <code>ImageLoader</code>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1929911-d052792e10260e74.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>dyld: The Dynamic Link Editor</p>
<ul>
<li><p>Apple 的动态链接库，系统内核做好启动程序的初始准备后，将其他事物交给 dyld 处理</p>
</li>
<li><p>详细可以看 <a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/" target="_blank" rel="external">sunnyxx</a></p>
</li>
</ul>
</li>
<li><p>ImageLoader：</p>
<ul>
<li><p>images 表示二进制文件（可执行文件或者动态链接库 .so 文件）编译后的符号、代码等</p>
</li>
<li><p>ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个 ImageLoader 实例来负责加载</p>
<ul>
<li>在程序运行时它先将动态链接的 image 递归加载</li>
<li>再从可执行文件 image 递归加载所有符号</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="load-流程"><a href="#load-流程" class="headerlink" title="load 流程"></a>load 流程</h2><ul>
<li>在分析 load 之前，还需要了解下 runtime 的初始化入口。</li>
</ul>
<h3 id="objc-init"><a href="#objc-init" class="headerlink" title="__objc_init"></a>__objc_init</h3><blockquote>
<p>Bootstrap initialization. Registers our image notifier with dyld.<br>Called by libSystem BEFORE library initialization time</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="number">_</span>objc_init(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</div><div class="line">    initialized = <span class="literal">true</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 环境初始化</span></div><div class="line">    environ_init();</div><div class="line">    tls_init();</div><div class="line">    static_init();</div><div class="line">    lock_init();</div><div class="line">    <span class="comment">// 初始化 libobjc 的异常处理系统</span></div><div class="line">    exception_init();</div><div class="line">    <span class="comment">// 添加通知、回调</span></div><div class="line">    <span class="number">_</span>dyld_objc_notify_register(&amp;map_2_images, load_images, unmap_image);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>引导初始化</li>
<li><p>注册通知，当二进制文件 images 加载到内存时，通知 runtime 进行处理。</p>
<ul>
<li><p><code>map_2_images</code>：处理已经被 mapped 的images</p>
</li>
<li><p><code>load_images</code>：处理 已被 mapped 的 images 中的 +load 方法</p>
</li>
<li><p><code>unmap_image</code>：处理将要 unmap 的 images</p>
</li>
</ul>
</li>
</ol>
<h3 id="1-load-images"><a href="#1-load-images" class="headerlink" title="1. load_images"></a>1. load_images</h3><blockquote>
<p>Process +load in the given images which are being mapped in by dyld</p>
</blockquote>
<ul>
<li>处理 dyld 提供的已被 map_images 处理后的 images 中的 +load 方法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">load_images</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path <span class="number">__u</span>nused, <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mh)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></div><div class="line">    <span class="comment">// 如果没有 load 方法，直接返回，</span></div><div class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">recursive_mutex_locker_t</span> lock(loadMethodLock);</div><div class="line"></div><div class="line">    <span class="comment">// Discover load methods</span></div><div class="line">    <span class="comment">// 收集 load 方法，为下面调用做准备</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">rwlock_writer_t</span> lock2(runtimeLock);</div><div class="line">        <span class="comment">// 准备所有的 load 方法</span></div><div class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></div><div class="line">    <span class="comment">// 调用 load 方法</span></div><div class="line">    call_load_methods();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>快速查询，类和分类的方法列表中是否含有 <code>load</code> 方法，如果没有，直接返回</p>
</li>
<li><p>递归查询所有的 <code>load</code> 方法，并存储起来</p>
</li>
<li><p>依次调用所有的 <code>load</code> 方法</p>
</li>
</ol>
<h4 id="1-2-prepare-load-methods"><a href="#1-2-prepare-load-methods" class="headerlink" title="1.2 prepare_load_methods"></a>1.2 prepare_load_methods</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void prepare_load_methods(<span class="keyword">const</span> headerType *mhdr)</div><div class="line">&#123;</div><div class="line">    size_t <span class="keyword">count</span>, i;</div><div class="line"></div><div class="line">    runtimeLock.assertWriting();</div><div class="line"></div><div class="line">    <span class="comment">// 收集所有类的列表</span></div><div class="line">    classref_t *classlist = </div><div class="line">        _getObjc2NonlazyClassList(mhdr, &amp;<span class="keyword">count</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (i = 0; i &lt; <span class="keyword">count</span>; i++) &#123;</div><div class="line">        <span class="comment">// 收集当前类和父类的 load 方法，父类优先</span></div><div class="line">        </div><div class="line">        schedule_class_load(remapClass(classlist[i]));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取所有的分类</span></div><div class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;<span class="keyword">count</span>);</div><div class="line">    <span class="keyword">for</span> (i = 0; i &lt; <span class="keyword">count</span>; i++) &#123;</div><div class="line">        category_t *<span class="keyword">cat</span> = categorylist[i];</div><div class="line">        <span class="comment">// 获取到分类对应的类的指针</span></div><div class="line">        <span class="keyword">Class</span> cls = remapClass(<span class="keyword">cat</span>-&gt;cls);</div><div class="line">        <span class="comment">// 若链接返回 nil， 如果是 弱链接，就跳过</span></div><div class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></div><div class="line">        </div><div class="line">        <span class="comment">// 对类进行第一次初始化，包括 读写空间，返回真正的类结构</span></div><div class="line">        realizeClass(cls);</div><div class="line">        <span class="keyword">assert</span>(cls-&gt;ISA()-&gt;isRealized());</div><div class="line">        <span class="comment">// 把 分类加入到一个全局列表中</span></div><div class="line">        add_category_to_loadable_list(<span class="keyword">cat</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>存储当前类和父类的所有 <code>load</code> 方法，其中父类优先</p>
</li>
<li><p>存储分类的 <code>load</code> 方法</p>
</li>
</ol>
<h5 id="1-2-1-schedule-class-load"><a href="#1-2-1-schedule-class-load" class="headerlink" title="1.2.1 schedule_class_load"></a>1.2.1 schedule_class_load</h5><blockquote>
<p>Schedule +load for classes in this image, any un-+load-ed superclasses in other images, and any categories in this image.</p>
</blockquote>
<ul>
<li>该方法是递归函数，找到未被加载的最顶级的父类，然后依次存储</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> void schedule_class_load(<span class="class"><span class="keyword">Class</span> <span class="title">cls</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</div><div class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></div><div class="line"></div><div class="line">    <span class="comment">// A. 判断 类 的 load 方法 是否被调用</span></div><div class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Ensure superclass-first ordering</span></div><div class="line">    schedule_class_load(cls-&gt;superclass);</div><div class="line"></div><div class="line">    <span class="comment">// 把 含有 load 方法的类 添加到 全局的 loadable_classes</span></div><div class="line">    add_class_to_loadable_list(cls);</div><div class="line">    <span class="comment">// 添加标记，对应 A</span></div><div class="line">    cls-&gt;setInfo(RW_LOADED); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-2-2-add-class-to-loadable-list"><a href="#1-2-2-add-class-to-loadable-list" class="headerlink" title="1.2.2 add_class_to_loadable_list"></a>1.2.2 add_class_to_loadable_list</h5><blockquote>
<p>Class cls has just become connected. Schedule it for +load if it implements a +load method</p>
</blockquote>
<ul>
<li>存储实现了 <code>load</code> 方法的类</li>
</ul>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void add_class_to_loadable_list(Class <span class="keyword">cls</span>)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 方法指针</span></div><div class="line">    IMP method;</div><div class="line"></div><div class="line">    </div><div class="line">    loadMethodLock.assertLocked();</div><div class="line">    </div><div class="line">    <span class="comment">// 方法内部会根据 方法名字 判断是否 load 方法，并返回</span></div><div class="line">    method = <span class="keyword">cls</span>-&gt;getLoadMethod();</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</div><div class="line">        _objc_inform(<span class="string">"LOAD: class '%s' scheduled for +load"</span>, </div><div class="line">                     <span class="keyword">cls</span>-&gt;nameForLogging());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</div><div class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</div><div class="line">        loadable_classes = (<span class="keyword">struct</span> loadable_class *)</div><div class="line">            realloc(loadable_classes,</div><div class="line">                              loadable_classes_allocated *</div><div class="line">                              sizeof(<span class="keyword">struct</span> loadable_class));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    loadable_classes[loadable_classes_used].<span class="keyword">cls</span> = <span class="keyword">cls</span>;</div><div class="line">    loadable_classes[loadable_classes_used].method = method;</div><div class="line">    loadable_classes_used++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>根据 “load” 获取对应方法的指针。其实方法实质上也是个对象，有它自己的成员变量，如下：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="keyword">method_t</span> &#123;</div><div class="line">    SEL name; </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types; </div><div class="line">    IMP imp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>静态全局数组存储，如果数组已满，动态扩容</p>
<ul>
<li><code>loadable_classes</code>：数组，里面元素是结构体 <code>loadable_class</code>，存储类名和方法指针。</li>
<li><code>loadable_classes_used</code>：数组内对象的个数，即已经存储的对象数量</li>
<li><code>loadable_classes_allocated</code>：数组大小</li>
</ul>
</li>
<li><p><code>add_category_to_loadable_list</code> 分类存储方法，几乎一致</p>
</li>
</ol>
<h3 id="2-call-load-methods"><a href="#2-call-load-methods" class="headerlink" title="2. call_load_methods"></a>2. call_load_methods</h3><blockquote>
<p>Call all pending class and category +load methods.<br>Class +load methods are called superclass-first.<br>Category +load methods are not called until after the parent class’s +load</p>
</blockquote>
<ul>
<li>依次执行已经被存储的 <code>load</code> 方法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// loading 设置为全局静态变量，保证只初始化一次，</span></div><div class="line">    <span class="comment">// 一旦执行一次， loading 即为 YES，</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = <span class="literal">NO</span>;</div><div class="line">    <span class="keyword">bool</span> more_categories;</div><div class="line"></div><div class="line">    loadMethodLock.assertLocked();</div><div class="line"></div><div class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></div><div class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</div><div class="line">    loading = <span class="literal">YES</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 创建自动释放池，在自动释放池中进行方法调用</span></div><div class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</div><div class="line"></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></div><div class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</div><div class="line">            call_class_loads();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 2. Call category +loads ONCE</span></div><div class="line">        more_categories = call_category_loads();</div><div class="line"></div><div class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></div><div class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</div><div class="line"></div><div class="line">    objc_autoreleasePoolPop(pool);</div><div class="line"></div><div class="line">    loading = <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>首先，保证是首次执行， <code>load</code> 方法只会执行一次。</p>
</li>
<li><p>创建自动释放池，在池内执行方法，优化性能</p>
</li>
<li><p><code>do {} while</code> 循环执行，直到数组为空，且分类方法也执行完毕，不再有新的分类方法</p>
</li>
</ol>
<h3 id="3-call-class-loads"><a href="#3-call-class-loads" class="headerlink" title="3. call_class_loads"></a>3. call_class_loads</h3><ul>
<li><code>call_class_loads</code> 方法比较简单，主要看分类方法的调用，这里涉及到在运行期间，后续又添加的 <code>load</code> 分类方法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">call_category_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i, shift;</div><div class="line">    <span class="keyword">bool</span> new_categories_added = NO;</div><div class="line">    </div><div class="line">    <span class="comment">// Detach current loadable list.</span></div><div class="line">    <span class="comment">// 1. 分离并获取当前的分类 列表 cats</span></div><div class="line">    <span class="keyword">struct</span> loadable_category *cats = loadable_categories;</div><div class="line">    <span class="keyword">int</span> used = loadable_categories_used;</div><div class="line">    <span class="keyword">int</span> allocated = loadable_categories_allocated;</div><div class="line">    loadable_categories = nil;</div><div class="line">    loadable_categories_allocated = <span class="number">0</span>;</div><div class="line">    loadable_categories_used = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Call all +loads for the detached list.</span></div><div class="line">    <span class="comment">// 2. for 循环 进行调用 load 方法，执行完毕后，把分类置空</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</div><div class="line">        Category cat = cats[i].cat;</div><div class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)cats[i].method;</div><div class="line">        Class cls;</div><div class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        cls = <span class="number">_</span>category_getClass(cat);</div><div class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123;</div><div class="line">            <span class="keyword">if</span> (PrintLoading) &#123;</div><div class="line">                <span class="number">_</span>objc_inform(<span class="string">"LOAD: +[%s(%s) load]\n"</span>, </div><div class="line">                             cls-&gt;nameForLogging(), </div><div class="line">                             <span class="number">_</span>category_getName(cat));</div><div class="line">            &#125;</div><div class="line">            (*load_method)(cls, SEL_load);</div><div class="line">            cats[i].cat = nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Compact detached list (order-preserving)</span></div><div class="line">    <span class="comment">// 3. 将加载过的分类方法移除 分离列表，保留未被加载过的 分类方法</span></div><div class="line">    shift = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (cats[i].cat) &#123;</div><div class="line">            cats[i-shift] = cats[i];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            shift++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    used -= shift;</div><div class="line"></div><div class="line">    <span class="comment">// Copy any new +load candidates from the new list to the detached list.</span></div><div class="line">    <span class="comment">// 运行过程中是否有新添加的分类方法</span></div><div class="line">    new_categories_added = (loadable_categories_used &gt; <span class="number">0</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 4. 如果有，先存储在 分离列表 cats </span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loadable_categories_used; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (used == allocated) &#123;</div><div class="line">            allocated = allocated*<span class="number">2</span> + <span class="number">16</span>;</div><div class="line">            cats = (<span class="keyword">struct</span> loadable_category *)</div><div class="line">                <span class="built_in">realloc</span>(cats, allocated *</div><div class="line">                                  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_category));</div><div class="line">        &#125;</div><div class="line">        cats[used++] = loadable_categories[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Destroy the new list.</span></div><div class="line">    <span class="comment">// 释放清空全局列表，以便后面重新赋值</span></div><div class="line">    <span class="keyword">if</span> (loadable_categories) <span class="built_in">free</span>(loadable_categories);</div><div class="line"></div><div class="line">    <span class="comment">// Reattach the (now augmented) detached list. </span></div><div class="line">    <span class="comment">// But if there's nothing left to load, destroy the list.</span></div><div class="line">    <span class="comment">// 5. 是否存在有新列表，并赋值给全局静态存储变量</span></div><div class="line">    <span class="keyword">if</span> (used) &#123;</div><div class="line">        loadable_categories = cats;</div><div class="line">        loadable_categories_used = used;</div><div class="line">        loadable_categories_allocated = allocated;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (cats) <span class="built_in">free</span>(cats);</div><div class="line">        loadable_categories = nil;</div><div class="line">        loadable_categories_used = <span class="number">0</span>;</div><div class="line">        loadable_categories_allocated = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</div><div class="line">        <span class="keyword">if</span> (loadable_categories_used != <span class="number">0</span>) &#123;</div><div class="line">            <span class="number">_</span>objc_inform(<span class="string">"LOAD: %d categories still waiting for +load\n"</span>,</div><div class="line">                         loadable_categories_used);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> new_categories_added;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>上述代码中详细给出了5步，判断是否还有更多的分类方法，来决定是否继续在 <code>while</code>循环中执行。</p>
</li>
<li><p>这里着重提下，由于 OC 运行时的机制，系统之前已经收集完所有的 <code>load</code> 方法，并且正在执行 <code>load</code> 方法的时候，又有含有 <code>load</code> 方法的分类被添加进来，所以在执行分类的时候，又多出来 3、4、5 步，来保证所有的分类实现完毕。</p>
</li>
</ul>
<h3 id="4-load"><a href="#4-load" class="headerlink" title="4. load"></a>4. load</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Load Hello World"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>从方法调用栈中，找到了系统在执行 <code>load</code> 前调用的方法：</p>
<ol>
<li><p>启动 dyld，将二进制文件初始化</p>
</li>
<li><p><code>ImageLoader</code> 把二进制文件加载进内存</p>
</li>
<li>runtime 执行<code>load_images</code>，执行所有的 <code>load</code>方法<ul>
<li>使用一个全局数组从含有 <code>load</code> 方法的根父类到自身，依次添加</li>
<li>使用另一个全局数组添加含有 <code>load</code> 方法的所有分类</li>
<li>依次执行存储的 <code>load</code> 方法，父类 -&gt; 自身 -&gt; 分类</li>
</ul>
</li>
<li>执行自定义的 <code>load</code> 方法</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.jianshu.com/p/1b8fb16d8a56" target="_blank" rel="external">load 的简单了解</a></p>
<p><a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/" target="_blank" rel="external">iOS 程序 main 函数之前发生了什么</a></p>
<p><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%20load%20%E6%96%B9%E6%B3%95%E4%B9%88%EF%BC%9F.md" target="_blank" rel="external">你真的了解 load 方法么？</a></p>
<p><a href="http://www.desgard.com/Load/" target="_blank" rel="external">load 方法全程跟踪</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RACCommand 粗解]]></title>
      <url>http://lionwy.github.io/RACCommand-%E7%B2%97%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><img src="http://oeb4c30x3.bkt.clouddn.com/20170226195647_XfLsex_paul-itkin-46110.jpeg" alt=""></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习 RAC 的过程中，<code>RACCommand</code> 是我一直很迷惑的点，感觉一直抓不到它的要点，不明白为何要这样使用。曾经想过用别的方法来替代，只要能找到替代的方法，暂时就没必要死磕，结果发现避免不了，那就解决他。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><blockquote>
<p>RACCommand 最常用于两个地方，监听按钮点击，网络请求</p>
</blockquote>
<ol>
<li><p>按钮点击，使用 RAC 有两种方式</p>
<ul>
<li><p><code>UIControl+RACSignalSupport</code></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- <span class="params">(RACSignal *)</span>rac_signalForControlEvents:<span class="params">(UIControlEvents)</span>controlEvents;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>UIButton+RACCommandSupport</code> </p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">property</span><span class="title"> </span>(nonatomic, strong) RACCommand *rac_command;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>第一种方式，也是我曾经想过替代 <code>RACCommand</code> 来处理按钮点击事件的方法</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 按钮是否可点击</span></div><div class="line">RAC(<span class="keyword">self</span>.commandBtn, enabled) = validSignal;</div><div class="line"></div><div class="line">[[[<span class="keyword">self</span>.commandBtn rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] </div><div class="line"> <span class="comment">// flattenMap 生成新的信号，在信号中可以处理点击事件，并发送结果</span></div><div class="line">   flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</div><div class="line">       <span class="keyword">return</span> [<span class="keyword">self</span> btnClickSignal];</div><div class="line">   &#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">       <span class="built_in">NSLog</span>(<span class="string">@"====%@"</span>, x); <span class="comment">// ====按钮点击了</span></div><div class="line">   &#125;];</div><div class="line">   </div><div class="line">- (RACSignal *)btnClickSignal &#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         *   这里可以进行处理按钮点击后的事件，并把想要的结果传递出去</div><div class="line">         */</div><div class="line">        [subscriber sendNext:<span class="string">@"按钮点击了"</span>];</div><div class="line">        </div><div class="line">        [subscriber sendCompleted];</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>上述就是根据 <code>UIControl</code> 的分类信息，进行处理按钮点击事件的第一种方式。但是有一个问题：</p>
</li>
<li><p>你只有手动点击了按钮，并且是 <code>UIControlEventTouchUpInside</code> 的事件状态下才会执行 block 中的代码。</p>
</li>
<li>如果需要主动触发事件呢，而在老代码中，可以手动调用 <code>[self btnClick]</code>，所以就必须使用第二种方式，<code>RACCommand</code>。</li>
</ul>
</li>
<li><p><code>RACCommand</code></p>
<ul>
<li><p>初始化赋值 <code>rac_command</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 初始化 command， enabled 表示按钮可否点击</span></div><div class="line">RACCommand *command = [[RACCommand alloc] initWithEnabled:validSignal </div><div class="line">                                             signalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</div><div class="line">                                                 </div><div class="line">                                                <span class="keyword">return</span> [<span class="keyword">self</span> btnClickSignal];</div><div class="line">                                                 </div><div class="line">                                             &#125;];</div><div class="line"><span class="keyword">self</span>.commandBtn.rac_command = command;</div></pre></td></tr></table></figure>
</li>
<li><p>监听</p>
<ul>
<li><code>executionSignals</code> 是信号中的信号</li>
<li>必须进行处理、转换，得到外层信号</li>
<li>监听最外层的信号，才能获取到信号中的信息</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 监听信号中的信号</span></div><div class="line">[command.executionSignals subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    [x subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"---%@"</span>, x);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 2. 使用 flattenMap 进行转换，返回最外层的信号</span></div><div class="line">[[command.executionSignals flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</div><div class="line">   <span class="keyword">return</span> value;</div><div class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"---%@"</span>, x); </div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3. switchToLatest 获取最新的信号，专门用于处理 信号中的信号</span></div><div class="line">[command.executionSignals.switchToLatest subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---%@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
<li><p><code>execute</code> 执行</p>
<ul>
<li>这也就是解决第一种方式无法主动触发事件方法。</li>
<li>相当于调用 <code>[self btnClick]</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 返回的是 RACSignal，可以被订阅</span></div><div class="line">[command execute:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="comment">// 2. 只有手动 执行命令，才能监听到信号</span></div><div class="line"><span class="comment">// 如果是 点击按钮, 这里是监听不到信息的</span></div><div class="line">[[command execute:<span class="literal">nil</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"execute---%@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
<li><p><code>executing</code> 是否正在执行命令</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// executing 一开始就会监听一次，肯定是 0，一般会忽略（skip）一次 </span></div><div class="line"><span class="comment">// x 非 0 即 1，命令执行完毕/正在执行</span></div><div class="line"><span class="comment">// 执行一次命令，block 中会调用两次，正在执行-&gt;执行完毕</span></div><div class="line">[[command.executing skip: <span class="number">1</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">   <span class="keyword">if</span> ([x integerValue] == <span class="number">1</span>) &#123;</div><div class="line">       <span class="built_in">NSLog</span>(<span class="string">@"正在执行"</span>);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="built_in">NSLog</span>(<span class="string">@"执行完毕"</span>);</div><div class="line">   &#125;    </div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol>
<li><p>上述就是 <code>RACCommand</code> 在按钮点击事件中的处理，网络请求的话，代码几乎一致，流程都是一样的。在初始化 <code>RACCommand</code> 的内部，进行事件处理/网络请求，并把结果通过 <code>subscriber</code> 发送出去，外部通过订阅信号，就可以获取事件处理的结果，从而进行 UI 更新。</p>
</li>
<li><p><code>RACCommand</code> 本质上就是用来处理事件的，事件如何处理，事件中的数据如何传递，甚至事件的执行过程，都可以表现出来。</p>
</li>
<li><p>见识浅薄，如有疑惑，欢迎交流，求吐槽，求成长。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[好玩的 RAC]]></title>
      <url>http://lionwy.github.io/RAC-%E4%B9%8B%E5%BC%95%E8%B5%B7%E4%BD%A0%E7%9A%84%E5%85%B4%E8%B6%A3/</url>
      <content type="html"><![CDATA[<p><img src="http://oeb4c30x3.bkt.clouddn.com/20170226195047_mJevEQ_ng-32703.jpeg" alt=""></p>
<ol>
<li><p>UIControl</p>
<ul>
<li>监听 control 点击</li>
<li><p>从此告别 <code>addTarget</code> 和 <code>btnClick</code></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[<span class="keyword">self.loginBtn </span>rac_signalForControlEvents:UIControlEventTouchUpInside] <span class="keyword">subscribeNext:^(UIButton </span>*<span class="keyword">btn) </span>&#123;</div><div class="line">   // <span class="keyword">btn, </span>即 <span class="keyword">self.loginBtn</span></div><div class="line">   // 这里执行点击之后的操作</div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>UITextField</p>
<ul>
<li>监听 textField 的 text 改变</li>
<li><p>告别 <code>UITextFieldDelegate</code></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self.myTF.rac_textSignal </span><span class="keyword">subscribeNext:^(NSString* </span>text) &#123;</div><div class="line">        </div><div class="line">  // text 即 <span class="keyword">self.myTF.text </span></div><div class="line">  // 每当 text 有改变时，就会进入到这个 <span class="keyword">block </span>中</div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>UILabel</p>
<ul>
<li><p>把 label 的属性 <code>text</code> 绑定在 <code>UITextField</code> 上</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// <span class="built_in">self</span>.myLab.text 随着 <span class="built_in">self</span>.myTF.text 的改变而改变</div><div class="line">RAC(<span class="built_in">self</span>.myLab, text) = <span class="built_in">self</span>.myTF.rac_textSignal;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>监听属性改变 </p>
<ul>
<li>一旦 person 的 name 有变化，就进入 block 里面</li>
<li><p>再不用写繁琐的 KVO</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[RACObserve(<span class="name">self.per</span>, name) subscribeNext:^(<span class="name">NSString</span> *name)</div><div class="line">&#123;</div><div class="line">    // name 即 self.per.name</div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>监听通知信息</p>
<ul>
<li><p>一旦键盘 frame 有所变化，就进入 block 里面</p>
</li>
<li><p>内部已经进行通知释放，不需要再 <code>dealloc</code> 中 移除</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillChangeFrameNotification object:nil] subscribeNext:^(<span class="name">NSNotification</span> *notification) &#123;</div><div class="line">  NSLog(@<span class="string">"-----%@"</span>, notification.description)<span class="comment">;</span></div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
<li><p>发送通知还是之前的办法</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] postNotificationName:@<span class="string">"通知名称"</span> object:nil]<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数组</p>
<ul>
<li><p>遍历</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@1, @2, @3, @4, @5];</div><div class="line"></div><div class="line">[array.rac_sequence.signal subscribeNext:^(id x) &#123;</div><div class="line">    // x 即 数组<span class="built_in"> array </span>的元素</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
</li>
<li><p>过滤 <code>filter</code>，并获取过滤后的数组</p>
<figure class="highlight golo"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> NSArray *<span class="keyword">filter</span> = [[<span class="keyword">array</span>.rac_sequence <span class="keyword">filter</span>:^BOOL(id value) &#123;</div><div class="line">    <span class="keyword">return</span>  [value integerValue] &gt; <span class="number">2</span>;</div><div class="line">&#125;] <span class="keyword">array</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>匹配、映射 <code>map</code>，变换元素并获取新数组</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *map = [[array.rac_sequence map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</div><div class="line">        </div><div class="line">   <span class="built_in">NSInteger</span> a = [value integerValue] * [value integerValue];</div><div class="line">   </div><div class="line">   <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>, a];</div><div class="line">   </div><div class="line">&#125;] array];</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>字典</p>
<ul>
<li><code>rac_keySequence</code> 和 <code>rac_valueSequence</code> 跟数组一样</li>
<li><p><code>rac_sequence</code> 需要 <code>RACTupleUnpack</code> 解包</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> NSDictionary *<span class="keyword">dic </span>= @&#123;@<span class="string">"name"</span>: @<span class="string">"lion"</span>, @<span class="string">"age"</span>: @<span class="number">18</span>&#125;<span class="comment">;</span></div><div class="line"> [<span class="keyword">dic.rac_sequence.signal </span><span class="keyword">subscribeNext:^(id </span>x) &#123;</div><div class="line">    RACTupleUnpack(NSString *key, NSString *value) = x<span class="comment">;</span></div><div class="line">    </div><div class="line">    NSLog(@<span class="string">"\r\nkey: %@\r\nvalue: %@"</span>, key, value)<span class="comment">;</span></div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>最经典的登录界面，登录按钮是否可点击</p>
<ul>
<li>先联合两个信号</li>
<li>再解析信号结果</li>
<li><p>最后把结果绑定到信号上</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RAC(<span class="keyword">self</span>.loginBtn, enabled) = [RACSignal </div><div class="line">                                   combineLatest:@[<span class="keyword">self</span>.usernameTF.rac_textSignal, <span class="keyword">self</span>.passwordTF.rac_textSignal] </div><div class="line">                                   reduce:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *username, <span class="built_in">NSString</span> *password)&#123;</div><div class="line">                                       <span class="keyword">return</span> @(username.length &gt; <span class="number">6</span> &amp;&amp; password.length &gt; <span class="number">8</span>);</div><div class="line">                               &#125;];</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>节流 <code>throttle</code></p>
<ul>
<li>表示 指定时间间隔内，不再发送信号</li>
<li>这里添加 <code>throttle</code>， 表示在 0.5 秒内 text 没有改变时，才会进行搜索请求</li>
<li><p>比如想搜索 <code>reactiveCocoa</code>，如果不添加 <code>throttle</code>，那么每输入一个字符，都会进行搜索请求，明显不是我们想要的。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[[self.searchTF rac_textSignal] </div><div class="line">    throttle:0.5] </div><div class="line">    subscribeNext:^(<span class="name">id</span> x) &#123;</div><div class="line">        NSLog(@<span class="string">"开始搜索请求==%@"</span>, x)<span class="comment">;</span></div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>一通组合拳：</p>
<ol>
<li><p>判断用户名是否符合规则，</p>
</li>
<li><p>用户名正确之后，进行判断密码是否符合规则</p>
</li>
<li><p>密码正确，进行请求验证，成功之后返回请求结果</p>
</li>
<li><p>返回主线程根据结果更新界面 UI</p>
</li>
</ol>
</li>
</ol>
<pre><code><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 判断用户名</span></div><div class="line">- (RACSignal *)validUsernameSignal &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 防止循环引用</span></div><div class="line">    @weakify(<span class="keyword">self</span>);</div><div class="line">    <span class="comment">// 因为返回的是一个信号，所以需要创建</span></div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        </div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">            </div><div class="line">        [[[[[<span class="keyword">self</span>.usernameTF rac_textSignal]</div><div class="line">            <span class="comment">// skip, 忽略，表示忽略几次信号</span></div><div class="line">            <span class="comment">// 这里两次分别是，首次加载的时候，和 TF 第一次响应的时候，</span></div><div class="line">            <span class="comment">// 可以把后面的 distinctUntilChanged 注释，测试下效果</span></div><div class="line">            skip:<span class="number">2</span>] </div><div class="line">            <span class="comment">// map, 变换，把信号内容的类型变换为另一种类型</span></div><div class="line">            <span class="comment">// 把字符串根据长度转换为 bool 类型的对象</span></div><div class="line">            map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *value) &#123;</div><div class="line">                <span class="keyword">return</span> @(value.length &gt; <span class="number">5</span>);</div><div class="line">                <span class="comment">// distinctUntilChanged 只有值不同时，才会发送信号</span></div><div class="line">                <span class="comment">// 这里为了防止，在值不满足/已满足 要求时，还继续发送信号</span></div><div class="line">            &#125;] distinctUntilChanged] </div><div class="line">            <span class="comment">// 这里订阅的信息，就是转换后的 bool 类型的对象，非 1 即 0</span></div><div class="line">            subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">                <span class="keyword">if</span> ([x integerValue] == <span class="number">1</span>) &#123;</div><div class="line">                    [subscriber sendNext:<span class="string">@"用户名正确"</span>];</div><div class="line">                    [subscriber sendCompleted];</div><div class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"-------用户名正确"</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"-------用户名错误"</span>);</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                </div><div class="line">            &#125;];</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>; </div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3. 请求验证</span></div><div class="line">- (RACSignal *)loginSuccessSignalWithPassword: (<span class="built_in">NSString</span> *)psw &#123;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 这里可以进行请求验证用户名密码，并返回结果</div><div class="line">         */</div><div class="line">        <span class="built_in">NSString</span> *str = <span class="string">@"用户信息 Data"</span>;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----登陆成功并返回用户信息 Data"</span>);</div><div class="line">        </div><div class="line">        <span class="built_in">NSDictionary</span> *dic = @&#123;<span class="string">@"data"</span>: str&#125;;</div><div class="line">        </div><div class="line">        [subscriber sendNext:dic];</div><div class="line">        [subscriber sendCompleted];</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2、4、密码验证和界面更新</span></div><div class="line">- (<span class="keyword">void</span>)loginResult &#123;</div><div class="line">    </div><div class="line">        <span class="comment">// 用户名的判断</span></div><div class="line">    [[[[[[[<span class="keyword">self</span> validUsernameSignal]</div><div class="line">        <span class="comment">// then, 只有前面的信号 发送信息，并完成才会继续</span></div><div class="line">        <span class="comment">// 下面进行 密码的判断</span></div><div class="line">        then:^RACSignal *&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.passwordTF.rac_textSignal;</div><div class="line">        &#125;] </div><div class="line">        <span class="comment">// throttle，间隔 0.5 秒，</span></div><div class="line">        <span class="comment">// 防止在输入密码过程中不断发送信号，优化性能</span></div><div class="line">        throttle:<span class="number">0.5</span>] </div><div class="line">        <span class="comment">// filter，过滤 ，只有符合要求的才能继续</span></div><div class="line">        filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span> *value) &#123;</div><div class="line">            <span class="keyword">return</span> [value length] &gt; <span class="number">6</span>;</div><div class="line">        &#125;] </div><div class="line">        <span class="comment">// flattenMap 根据源信号的内容生成新的信号，后续订阅、监听的就是新信号的内容</span></div><div class="line">        <span class="comment">// 常用于在信号嵌套中，处理信号中的信号</span></div><div class="line">        <span class="comment">// 这里使用 flattenMap 生成新的信号，并且在信号内发送登录结果信息，以便后续传递信息</span></div><div class="line">        flattenMap:^RACStream *(<span class="built_in">NSString</span> *value) &#123;</div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> loginSuccessSignalWithPassword:value];</div><div class="line">        &#125;]</div><div class="line">        <span class="comment">// deliverOn 切换线程，</span></div><div class="line">        <span class="comment">// RACScheduler, 即 RAC 中的多线程</span></div><div class="line">        <span class="comment">// 切换为主线程</span></div><div class="line">        deliverOn:[RACScheduler mainThreadScheduler]] </div><div class="line">        <span class="comment">// 订阅信号，获取信号传递的数据 data</span></div><div class="line">        subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"获取信息 \r\n%@，\r\n更新 UI"</span>, x);</div><div class="line">        &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><ul>
<li><p><code>ReactiveCocoa</code> 虽然说是思想上的巨大改变，但我更倾向于把它当做一种新型语法、更简便的语法来使用，在使用过程中，自然而然地就会体会它跟你以往编程的不同。使用多了，就会发现，原来这就是函数式响应式编程。</p>
</li>
<li><p><strong><em>语法上的使用，只是理解编程思想的入口，思想上的一小步才是编程上的一大步。</em></strong></p>
</li>
<li><p>理论是实践出来的，在你不懂理论的时候，那就赶紧实践吧。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Autorelease 详解]]></title>
      <url>http://lionwy.github.io/Autorelease-%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="Autorelease"><a href="#Autorelease" class="headerlink" title="Autorelease"></a>Autorelease</h1><blockquote>
<p>一个对象调用 <code>autorelease</code> 方法，就会被自动添加到最近的自动释放池 <code>autoreleasepool</code>，只有当自动释放池被销毁的时候，才会执行 <code>release</code> 方法，进行释放。</p>
</blockquote>
<ul>
<li><p>下文源码是当前最新版本<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">objc4-706.tar.gz</a>，跟之前版本会有点差别，没有了特别牛的<code>POOL_SENTINEL</code>（哨兵对象），改为了<code>POOL_BOUNDARY</code>（边界对象），可能更好理解一点。</p>
</li>
<li><p>研究源码也可以看<a href="https://github.com/LionWY/SourceCodeStorage/blob/master/Demo/objc4-706/runtime/NSObject.mm#L568-L1250" target="_blank" rel="external">这里</a></p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1929911-c3f9bffc332f4975.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="autoreleasepool"></p>
<h2 id="1-入口"><a href="#1-入口" class="headerlink" title="1. 入口"></a>1. 入口</h2><blockquote>
<p>runtime 的 <code>NSObject.mm</code> 文件中 <code>autorelease</code> 方法</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)autorelease &#123;</div><div class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootAutorelease();</div><div class="line">&#125;</div><div class="line"></div><div class="line">objc_object::rootAutorelease()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> rootAutorelease2();</div><div class="line">&#125;</div><div class="line"></div><div class="line">objc_object::rootAutorelease2()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease((<span class="keyword">id</span>)<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">   <span class="keyword">id</span> *dest __unused = autoreleaseFast(obj);</div><div class="line">   <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-AutoreleasePoolPage"><a href="#2-AutoreleasePoolPage" class="headerlink" title="2. AutoreleasePoolPage"></a>2. AutoreleasePoolPage</h2><ol>
<li><p>关键词：</p>
<ul>
<li><code>EMPTY_POOL_PLACEHOLDER</code><ul>
<li>当一个释放池没有包含任何对象，又刚好被推入栈中，就存储在TLS（Thread_local_storage）中，叫做空池占位符</li>
</ul>
</li>
<li><code>POOL_BOUNDARY</code><ul>
<li>边界对象，代表 <code>AutoreleasePoolPage</code> 中的第一个对象</li>
</ul>
</li>
</ul>
</li>
<li><p>结构：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> AutoreleasePoolPage </div><div class="line">&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic; <span class="comment">// 当前类完整性的校验</span></div><div class="line">    id *next;</div><div class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread; <span class="comment">// 当前类所处的线程</span></div><div class="line">    </div><div class="line">    <span class="comment">// 双向链表 父子指针</span></div><div class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;</div><div class="line">    AutoreleasePoolPage *child;</div><div class="line">    </div><div class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;</div><div class="line">    <span class="keyword">uint32_t</span> hiwat;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE = PAGE_MAX_SIZE; <span class="comment">// 4096</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>一个 poolPage 对应于一个线程</li>
<li><code>AutoreleasePoolPage</code> 是以 <strong>双向链表</strong> 的形式连接起来的，其中 <code>parent</code> <code>child</code> 分别是父结点（指向父类poolPage的指针）和子结点（指向子类poolPage的指针）</li>
<li>一个 poolPage 的大小 是 4096 字节。其中56 bit 用来存储其成员变量，剩下的存储加入到自动释放池中的对象。<ul>
<li>调用 <code>autorelease</code> 的对象</li>
<li>声明在<code>@autoreleasepool{}</code> 中的对象</li>
</ul>
</li>
<li>next 指向最新添加进来的对象所处的位置。</li>
</ul>
</li>
</ol>
<h3 id="autoreleaseFast"><a href="#autoreleaseFast" class="headerlink" title="autoreleaseFast()"></a>autoreleaseFast()</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">AutoreleasePoolPage *<span class="built_in">page</span> = hotPage();</div><div class="line"> </div><div class="line"><span class="function"><span class="title">if</span> (<span class="built_in">page</span> &amp;&amp; !<span class="built_in">page</span>-&gt;</span>full()) &#123;</div><div class="line"><span class="function"><span class="title">return</span> <span class="built_in">page</span>-&gt;</span>add(obj);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">page</span>) &#123;</div><div class="line">return autoreleaseFullPage(obj, <span class="built_in">page</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">return autoreleaseNoPage(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p><code>hotPage()</code> 获取当前正在使用的 poolPage</p>
</li>
<li><p>如果 page 存在，并且未满，直接进行添加</p>
</li>
<li><p>如果 page 存在，但是当前 poolPage 已满：</p>
<ul>
<li>根据 page 遍历其所有的子 page，直到找到一个未满的子 page</li>
<li><p>否则就根据最后一个子 page，创建一个新的 page</p>
  <figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">  <span class="function"><span class="title">if</span> (<span class="built_in">page</span>-&gt;</span><span class="function"><span class="title">child</span>) <span class="built_in">page</span> = <span class="built_in">page</span>-&gt;</span>child;</div><div class="line">  <span class="keyword">else</span> <span class="built_in">page</span> = new AutoreleasePoolPage(<span class="built_in">page</span>);</div><div class="line">&#125; <span class="function"><span class="title">while</span> (<span class="built_in">page</span>-&gt;</span>full());</div></pre></td></tr></table></figure>
</li>
<li><p>设置为 hotPage <code>setHotPage(page);</code></p>
</li>
<li>添加 <code>return page-&gt;add(obj);</code></li>
</ul>
</li>
<li><p>如果 page 不存在</p>
 <figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">AutoreleasePoolPage *page = new AutoreleasePoolPage(<span class="name">nil</span>)<span class="comment">;</span></div><div class="line">setHotPage(<span class="name">page</span>)<span class="comment">;   </span></div><div class="line">page-&gt;add(<span class="name">POOL_BOUNDARY</span>)<span class="comment">;</span></div><div class="line">return page-&gt;add(<span class="name">obj</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<ul>
<li>创建第一个 page，第一个 page 是没有父结点的</li>
<li>设置为当前正在使用的 page </li>
<li>添加边界对象，初始化的第一个poolPage 存储的第一个对象，必定是边界对象 <code>POOL_BOUNDARY</code></li>
<li>添加对象</li>
</ul>
</li>
</ol>
<h3 id="page-gt-add"><a href="#page-gt-add" class="headerlink" title="page -&gt; add()"></a>page -&gt; add()</h3><blockquote>
<p>添加对象</p>
</blockquote>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id *ret = <span class="keyword">next</span><span class="comment">;  </span></div><div class="line">*<span class="keyword">next</span>++ = obj<span class="comment">;</span></div></pre></td></tr></table></figure>
<ol>
<li>获取 next 指针所处位置，并向上移动</li>
<li>把对象添加到 next 所处位置</li>
</ol>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>一个对象，调用 <code>autorelease</code> 方法，实际是把该对象加入到当前线程正在使用的 <code>autoreleasePoolPage</code> 的栈中，但它怎么释放呢？ARC 下唯一能看到 <code>autorelease</code> 的就是入口函数 <code>main.m</code> 中的 <code>@autoreleasepool{}</code>。</p>
<h2 id="3-autoreleasepool"><a href="#3-autoreleasepool" class="headerlink" title="3. @autoreleasepool{}"></a>3. @autoreleasepool{}</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;  </div><div class="line">   <span class="meta">@autoreleasepool</span> &#123;</div><div class="line">       </div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>使用 <code>clang -rewrite-objc main.m</code>重新编译，结果如下：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="number">__</span>AtAutoreleasePool &#123;</div><div class="line">  <span class="number">__</span>AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</div><div class="line">  ~<span class="number">__</span>AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</div><div class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; <span class="number">__</span>AtAutoreleasePool <span class="number">__</span>autoreleasepool; </div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>@autoreleasepool{}</code> 实际调用的是两个方法<code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code></li>
<li>objc_autoreleasePoolPush 方法内部实际就是 2.1， <code>autoreleaseFast()</code> 函数，不过，参数是 <code>POOL_BOUNDARY</code> 边界对象</li>
<li>每创建一个自动释放池，就会在当前线程的 poolPage 的栈中先添加一个边界对象，然后把池中的对象添加进去，直至栈满，创建子 page，继续添加。</li>
</ul>
</li>
</ul>
<h3 id="objc-autoreleasePoolPop"><a href="#objc-autoreleasePoolPop" class="headerlink" title="objc_autoreleasePoolPop()"></a>objc_autoreleasePoolPop()</h3><ul>
<li><p>该方法内部实际调用的是 <code>AutoreleasePoolPage</code> 的 <code>pop()</code> 方法，主要代码如下</p>
  <figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">static inline void pop(void *token) </div><div class="line">&#123;</div><div class="line">   AutoreleasePoolPage *<span class="built_in">page</span>;</div><div class="line">   id *stop;</div><div class="line"></div><div class="line">     <span class="comment">// 根据指针 token 获取token所在的 page</span></div><div class="line">   <span class="built_in">page</span> = pageForPointer(token);</div><div class="line">   stop = (id *)token;</div><div class="line">   </div><div class="line">    <span class="comment">/*</span></div><div class="line">     *   如果stop 不是边界对象，进行其他处理</div><div class="line">     *   如果stop 是边界对象，进行下面的步骤，来释放</div><div class="line">     */</div><div class="line">   </div><div class="line">    <span class="comment">// 释放栈中的所有对象，直至stop，</span></div><div class="line">    <span class="comment">// 此时，stop是边界对象，即 创建 autoreleasepool 时      </span></div><div class="line">    <span class="comment">// 添加的第一个对象</span></div><div class="line">   <span class="function"><span class="title">page</span>-&gt;</span>releaseUntil(stop);</div><div class="line"></div><div class="line">    <span class="function"><span class="title">if</span> (<span class="built_in">page</span>-&gt;</span>child) &#123;</div><div class="line">       <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></div><div class="line">       <span class="comment">// 不足一半满， 删除所有的子 page，</span></div><div class="line">       <span class="comment">// 否则 删除所有的孙 page</span></div><div class="line">       <span class="function"><span class="title">if</span> (<span class="built_in">page</span>-&gt;</span>lessThanHalfFull()) &#123;</div><div class="line">           <span class="function"><span class="title">page</span>-&gt;</span><span class="function"><span class="title">child</span>-&gt;</span>kill();</div><div class="line">       &#125;</div><div class="line">       <span class="function"><span class="title">else</span> <span class="keyword">if</span> (<span class="built_in">page</span>-&gt;</span><span class="function"><span class="title">child</span>-&gt;</span>child) &#123;</div><div class="line">           <span class="function"><span class="title">page</span>-&gt;</span><span class="function"><span class="title">child</span>-&gt;</span><span class="function"><span class="title">child</span>-&gt;</span>kill();</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>stop 是边界对象，即创建 <code>autoreleasepool</code> 时 page 栈中添加的第一个对象</p>
</li>
<li><p><code>page-&gt;releaseUntil(stop)</code> 方法，会对 page 栈中 stop 上面的所有对象调用 <code>objc_release(obj)</code> 方法，除了边界对象 <code>POOL_BOUNDARY</code>   </p>
</li>
<li><p><code>kill()</code> 方法，会删除当前 page 及其所有的子 page， 即 <code>page-&gt;child = nil;</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h3><ol>
<li>对象释放的过程：首先找到当前对象所处的 AutoreleasePoolPage，然后获取到创建 page 时添加的第一个边界对象 <code>POOL_BOUNDARY</code>，边界对象之后的添加进来的所有对象调用 <code>release</code>，进行释放。</li>
<li>创建自动释放池 <code>@autoreleasepool{}</code>的过程：获取到正在使用的 AutoreleasePoolPage，首先添加边界对象 <code>POOL_BOUNDARY</code>，如果有其他对象，则进行添加。最后进行释放，同上1。</li>
</ol>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol>
<li><p><code>autoreleasepool</code> 机制跟栈一样，每创建一个，就将其推入栈中，而清空 <code>autoreleasepool</code>，相当于将其从栈中弹出</p>
</li>
<li><p>一个对象调用 <code>autorelease</code> 方法，就会进入最近的 <code>autoreleasepool</code>，也就是栈顶的那个。</p>
</li>
<li><p>自动释放池的创建：</p>
<ul>
<li><p>长时间在后台运行的任务，入口函数(<code>main.m</code>)，系统自动创建 <code>autoreleasepool</code></p>
</li>
<li><p>主线程或GCD中的线程，会自动创建 <code>autoreleasepool</code>, 关系是一对多的关系，即一个线程可以有多个 <code>autoreleasepool</code></p>
</li>
<li><p>人为手动创建 <code>@autoreleasepool{}</code></p>
<ul>
<li>程序不是基于 UI framework，如命令行</li>
<li>创建大量的临时对象，降低内存峰值</li>
<li>创建了新线程</li>
</ul>
</li>
</ul>
</li>
<li><p>事件开始前，系统会自动创建 <code>autoreleasepool</code>， 然后在结束时，进行 <code>drain</code>，对释放池内的所有对象执行 <code>release</code> 方法</p>
</li>
</ol>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol>
<li><p>理论：</p>
<ul>
<li><p><a href="https://developer.apple.com/reference/foundation/nsautoreleasepool#//apple_ref/occ/cl/NSAutoreleasePool" target="_blank" rel="external">NSAutoreleasePool</a></p>
</li>
<li><p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/34.%E4%BB%A5%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E5%9D%97%E9%99%8D%E4%BD%8E%E5%86%85%E5%AD%98%E5%B3%B0%E5%80%BC.md#以自动释放池降低内存峰值" target="_blank" rel="external">以自动释放池降低内存峰值</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/5559bc15490d" target="_blank" rel="external">iOS中autorelease的那些事儿</a></p>
</li>
</ul>
</li>
<li><p>实践：</p>
<ul>
<li><p><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/#jtss-tsina" target="_blank" rel="external">Objective-C Autorelease Pool 的实现原理</a></p>
</li>
<li><p><a href="http://draveness.me/autoreleasepool/" target="_blank" rel="external">自动释放池的前世今生</a></p>
</li>
<li><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease</a></p>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React Native 和 Native 之间自由切换]]></title>
      <url>http://lionwy.github.io/React%20Native%20%E5%92%8C%20Native%20%E4%B9%8B%E9%97%B4%E8%87%AA%E7%94%B1%E5%88%87%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p>其实在学习 RN 的时候，一直都有种想法，RN 在界面布局上确有其独到之处，但有时候并不如 <code>Native</code> 来的舒服，而且第三方的控件/组件也没有 <code>Native</code> 的丰富，因此就想有些界面能不能 <code>Native</code> 来写，然后再跳回 <code>React Native</code>，并且可以相互传参，应该是种很爽的体验。</p>
<ol>
<li><p>首先创建RN项目，定下基调，整个 APP 大部分都是通过 <code>RN</code> 实现的，因莫名的原因，个别页面要使用 <code>iOS</code> 实现。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RN 命令行创建项目</span></div><div class="line">react-<span class="keyword">native</span> init RNJump</div></pre></td></tr></table></figure>
</li>
<li><p>几乎所有的 App 都有 <code>Navigator</code>，为了方便（懒），就直接使用 <code>NavigatorIOS</code>，并设置了根视图 <code>Root</code></p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;NavigatorIOS</div><div class="line"></div><div class="line">	 initialRoute=&#123;&#123;</div><div class="line">	     component: Root,</div><div class="line">	     title: <span class="string">'RN 首页'</span>,</div><div class="line">	</div><div class="line">	 &#125;&#125;</div><div class="line">	 barTintColor= <span class="string">'cyan'</span></div><div class="line">	 style=&#123;&#123;flex: <span class="number">1</span>&#125;&#125;</div><div class="line">	</div><div class="line"> /&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>RN传参：<code>root</code> 页面 <code>push</code> 下一个页面，并传递一个简单的参数 <code>text: &#39;root&#39;</code></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> &lt;Text onPress=&#123;()=&gt;&#123;</div><div class="line">    this<span class="selector-class">.props</span><span class="selector-class">.navigator</span><span class="selector-class">.push</span>(&#123;</div><div class="line">        component: Second,</div><div class="line">        title: <span class="string">'RN第二页'</span>,</div><div class="line">        passProps: &#123;</div><div class="line">            text: <span class="string">'root'</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;)</div><div class="line">&#125;&#125;&gt;</div><div class="line">   跳到第二页</div><div class="line">&lt;/Text&gt;</div></pre></td></tr></table></figure>
</li>
<li><p><code>iOS</code> 准备工作：因为 <code>RN</code> 中实现了<code>Navigator</code>, 所以在 <code>iOS</code> 中也要有对应的 <code>NavigationController</code>，最主要的也是要实现 push 动画，当然自定义也是可以的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AppDelegate.m</span></div><div class="line">  <span class="built_in">UIViewController</span> *rootViewController = [<span class="built_in">UIViewController</span> new];</div><div class="line">  rootViewController.view = rootView;</div><div class="line">  </div><div class="line">  <span class="keyword">self</span>.navi = [[<span class="built_in">UINavigationController</span> alloc] initWithRootViewController:rootViewController];</div><div class="line">  <span class="keyword">self</span>.window.rootViewController = <span class="keyword">self</span>.navi;</div><div class="line">  <span class="comment">// 这里设置hidden，是为了不覆盖 RN 中的 navigator</span></div><div class="line">  <span class="keyword">self</span>.navi.navigationBar.hidden = <span class="literal">YES</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>这时候 iOS 有自己的<code>navigationController</code>， RN 也有它的 <code>navigator</code>，虽然表现形式一样，但是相互之间并不能真正调用彼此，必须要有一个方法在中间搭桥。这就需要之前的<a href="http://www.jianshu.com/p/2595a558be29" target="_blank" rel="external">RN 调用 Native模块</a>中的调用方法</p>
<ul>
<li>实现协议 <code>&lt;RCTBridgeModule&gt;</code></li>
<li>实现跳转方法 <code>RCT_EXPORT_METHOD</code></li>
<li><p>RN 调用方法，进行跳转和传参</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NativeViewController.m</span></div><div class="line">RCT_EXPORT_MODULE(NativeVC);</div><div class="line"></div><div class="line">  <span class="comment">// RN 调用该方法，并且传参</span></div><div class="line">RCT_EXPORT_METHOD(goToNextWith:(NSString *)aStr) &#123;</div><div class="line">   <span class="comment">// 这里必须返回主线程进行 push</span></div><div class="line">   dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">       AppDelegate *app= (AppDelegate *)[[UIApplication sharedApplication] delegate];</div><div class="line">       self.paramsString = aStr;</div><div class="line">       [app.navi pushViewController:self animated:YES];</div><div class="line">   &#125;);</div><div class="line"> </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// second.js</span></div><div class="line"><span class="keyword">import</span> &#123;NativeModules&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> native = NativeModules.NativeVC;</div><div class="line"></div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">Text</span> <span class="attr">onPress</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></div><div class="line">       native.goToNextWith('我是从js过来的');</div><div class="line">    &#125;&#125;&gt;</div><div class="line">      跳到Native</div><div class="line"><span class="tag">&lt;/<span class="name">Text</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>最后就是从 iOS 再回到 RN，这个就比较简单了，其实就是第 1 步的手动实现</p>
<ul>
<li>创建下一个 VC <code>NextNativeViewController</code></li>
<li><code>RCTRootView</code> 替换 <code>VC.view</code></li>
<li><p>传参是通过 <code>initialProperties:</code> 字典传递的，当然也可以手动赋值属性 <code>rootView.appProperties</code></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NextNativeViewController.m</span></div><div class="line"> NSDictionary *dic = @&#123;@<span class="string">"text"</span>: @<span class="string">"从Xcode传过来的参数"</span>&#125;;</div><div class="line">   NSURL *jsCodeLocation;</div><div class="line"> </div><div class="line">   jsCodeLocation = [[RCTBundleURLProvider sharedSettings] <span class="string">jsBundleURLForBundleRoot:</span>@<span class="string">"NextSecond"</span> <span class="string">fallbackResource:</span>nil];</div><div class="line"> </div><div class="line">   RCTRootView *rootView = [[RCTRootView alloc] <span class="string">initWithBundleURL:</span>jsCodeLocation <span class="string">moduleName:</span>@<span class="string">"NextSecond"</span> <span class="string">initialProperties:</span>dic <span class="string">launchOptions:</span>nil];</div><div class="line">   rootView.backgroundColor = [[UIColor alloc] <span class="string">initWithRed:</span><span class="number">1.0</span>f <span class="string">green:</span><span class="number">1.0</span>f <span class="string">blue:</span><span class="number">1.0</span>f <span class="string">alpha:</span><span class="number">1</span>];</div><div class="line"> </div><div class="line">   self.view = rootView;</div><div class="line">   </div><div class="line">   <span class="comment">// NextSecond.js </span></div><div class="line">   export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">NextSecond</span> <span class="keyword">extends</span> <span class="title">Component</span> &#123;</span>&#125;</div><div class="line">   <span class="comment">// 注册'NextSecond' 必须跟 moduleName 一致</span></div><div class="line">   AppRegistry.registerComponent(<span class="string">'NextSecond'</span>, ()=&gt; NextSecond);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>这时候外层使用 iOS 的 <code>VC</code>，内层使用 RN 的 <code>rootView</code>，你可以在 js 文件中处理所有UI和逻辑。但是，跳转下一个页面的时候，还是只能按照第 6 步的方式进行包装，如果想像第 3 步那样，就必须再一次实现第 2 步，重新初始化一个 RN 的 <code>navigator</code>, 并设置 <code>component</code></p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;NavigatorIOS</div><div class="line"></div><div class="line">     initialRoute=&#123;&#123;</div><div class="line">         component: RealView,</div><div class="line">         title: <span class="string">'RealView'</span>,</div><div class="line">         passProps:&#123;text: this.props.text&#125;</div><div class="line"></div><div class="line">     &#125;&#125;</div><div class="line">     barTintColor= <span class="string">'cyan'</span></div><div class="line">     style=&#123;&#123;flex: <span class="number">1</span>&#125;&#125;</div><div class="line"></div><div class="line"></div><div class="line"> /&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="http://oeb4c30x3.bkt.clouddn.com/QQ20161218-1.png" alt="RN -&gt; N"></p>
<p>简单画了个流程图可能会清晰易懂一点。<a href="https://github.com/LionWY/React-Native-Test/tree/master/RNJump" target="_blank" rel="external">源码这里</a></p>
<p>原本还想写点，反过来的情况，即，App 大部分是 <code>Native</code> 实现的，部分页面需要 <code>RN</code> 实现，这之间怎么跳转、传参，又想了想，几乎一样，就不啰嗦了，虽然当初不明白的时候想了好久，但真正想明白了，其实很简单。当然也写了个demo，有兴趣可以看看<a href="https://github.com/LionWY/React-Native-Test/tree/master/Jump" target="_blank" rel="external">这里</a>。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol>
<li><p><code>RN</code> 本质上就是写界面UI的，声明了 <code>RCTRootView</code> 嵌在 <code>ViewController</code>里面。不过这个 view 在 RN 中可以当成 VC 来使用，真正跳转到 Native 的时候，就显露本质了。</p>
</li>
<li><p>iOS 中的 <code>navigationController.navigationBar</code> 跟 RN 中的 <code>navigator</code> 虽然表现形式相同，但并不能共用，而且 iOS 会覆盖RN的实现。因此，必须分开处理，iOS 中就需要隐藏 <code>navigationBar</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</div><div class="line">&#123;</div><div class="line">	    [<span class="keyword">super</span> viewWillAppear:animated];</div><div class="line">	    <span class="keyword">self</span>.navigationController.navigationBar.hidden = <span class="literal">NO</span>;</div><div class="line">    </div><div class="line"> &#125;</div><div class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated</div><div class="line">&#123;</div><div class="line">	    [<span class="keyword">super</span> viewWillDisappear:animated];</div><div class="line">	    <span class="keyword">self</span>.navigationController.navigationBar.hidden = <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 当然如果是自定义导航栏的话不用考虑这个问题。</p>
</li>
<li><p>RN 和 N 之间自由切换，目前想到的是这个方法，当然还没研究源码， 后续也许会有更好的解决办法，可以共用一个导航栏，而不必分开处理。</p>
</li>
<li><p>浅薄之见，如果有错误的地方，万望指正，感激不尽！</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React Native 调用 Native 模块]]></title>
      <url>http://lionwy.github.io/React-Native-%E8%B0%83%E7%94%A8-Native-%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<p><img src="http://oeb4c30x3.bkt.clouddn.com/dropg86ms2zsija-dan-carlson.jpg" alt=""></p>
<ol>
<li><p>声明一个类，必须实现<code>&lt;RCTBridgeModule&gt;</code> 协议</p>
</li>
<li><p>.m文件中实现宏定义<code>RCT_EXPORT_MODULE（）</code>，当它加载的时候，会自动注册</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// js_name 就是react native 获取类时所对应的名称，</span></div><div class="line"><span class="comment">// 即 NativeModules.js_name</span></div><div class="line"><span class="comment">// 传空的话，名称就是类名字</span></div><div class="line"><span class="comment">// #define RCT_EXPORT_MODULE(js_name)</span></div><div class="line"><span class="comment">// .m 文件</span></div><div class="line">RCT_EXPORT_MODULE(Test);</div><div class="line">	</div><div class="line"><span class="comment">// js 文件</span></div><div class="line"><span class="keyword">import</span> &#123;NativeModules&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"><span class="keyword">var</span> Test = NativeModules.Test;</div></pre></td></tr></table></figure>
</li>
<li><p>调用方法，js调用OC的方法</p>
<ul>
<li>需要另外一个宏<code>RCT_EXPORT_METHOD(method)</code>，js 中 使用<code>.</code>来调用</li>
<li>方法返回值类型必须为<code>void</code></li>
<li><p>传参类型</p>
<ul>
<li>string: NSString</li>
<li>number: 基本类型</li>
<li>boolean</li>
<li>array</li>
<li>object: NSDictionary, key为string，value是列表中的类型</li>
<li>function: RCTResponseSenderBlock</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// .m 文件</span></div><div class="line">RCT_EXPORT_METHOD(<span class="built_in">print</span>:(NSString *)<span class="built_in">text</span>)</div><div class="line">&#123;</div><div class="line">    NSLog(@<span class="string">"---------%@"</span>, <span class="built_in">text</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// js文件</span></div><div class="line">Test.<span class="built_in">print</span>(<span class="string">'Hello World!'</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>回调函数，js中的参数经过OC方法的处理，结果再返回给js</p>
<ul>
<li><code>RCTResponseSenderBlock</code> 唯一参数，数组</li>
<li><p>第一个元素一般为错误对象，第二个元素才是返回结果</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// .m</span></div><div class="line">RCT_EXPORT_METHOD(<span class="string">add:</span>(NSInteger)numA <span class="string">andNumB:</span>(NSInteger)numB <span class="string">result:</span>(RCTResponseSenderBlock)callback) &#123;</div><div class="line">    	callback(@[[NSNull <span class="literal">null</span>], @(numA + numB)]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// js</span></div><div class="line">Test.add(<span class="number">1</span>, <span class="number">2</span>, (error, result)=&gt;&#123;</div><div class="line">   alert(<span class="string">'1 + 2 ='</span> + result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>设定原生模块所处线程</p>
<ul>
<li>实现<code>- (dispatch_queue_t) methodQueue</code>，即原生模块中的所有方法都会在<code>methodQueue</code>中执行</li>
<li><p>也可以<code>RCT_EXPORT_METHOD()</code>方法内部开辟分线程，让一些费时的操作在分线程中执行</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">RCT_EXPORT_METHOD</span>(<span class="attribute">doSomethingExpensive</span>:(NSString *)parma <span class="attribute">callback</span>:(RCTResponseSenderBlock)callback) &#123;</div><div class="line">	<span class="selector-tag">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line"> </div><div class="line">       		<span class="comment">// 执行长时间的操作</span></div><div class="line">        </div><div class="line">       		<span class="comment">// callback视情况 1， 2 位置都可以</span></div><div class="line">       		<span class="comment">// 1. callback(@[]);</span></div><div class="line">	&#125;);</div><div class="line">   </div><div class="line">		<span class="comment">// 2. callback(@[]);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>导出常量</p>
<ul>
<li>原生模块导出一些常量，让js可以随时访问，并且运行期间不会改变</li>
<li><p>方法名必须是<code>- (NSDictionary *)constantsToExport</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// .m</span></div><div class="line">- (NSDictionary *)constantsToExport</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> @&#123;</div><div class="line">             @<span class="string">"firstDayOfWeek"</span>: @<span class="string">"Monday"</span></div><div class="line">             &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// js</span></div><div class="line">alert(Test.firstDayOfWeek);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>发送事件</p>
<ol>
<li><p>类需要继承<code>RCTEventEmitter</code></p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RCTEventEmitter.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"RCTBridgeModule.h"</span></span></div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyModule</span> : <span class="title">RCTEventEmitter</span> 	&lt;<span class="title">RCTBridgeModule</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>实现<code>supportedEvents</code>方法，设置发送事件的名称</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注册该类，对外名称为RN，</span></div><div class="line">RCT_EXPORT_MODULE(RN);</div><div class="line"><span class="comment">// 设置可以发送的事件名称数组</span></div><div class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)supportedEvents</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> @[<span class="string">@"textChange"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)changeText:(<span class="built_in">NSString</span> *)text</div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.text = text;</div><div class="line">    <span class="comment">// 发送事件</span></div><div class="line">    [<span class="keyword">self</span> sendEventWithName:<span class="string">@"textChange"</span> body:@&#123;</div><div class="line">                                                 <span class="string">@"text"</span>: <span class="keyword">self</span>.text</div><div class="line">                                                 &#125;];        </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>js文件中</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; NativeModules, NativeEventEmitter &#125; from <span class="string">'react-native'</span></div><div class="line"><span class="comment">// 获取组件RN</span></div><div class="line"><span class="keyword">var</span> RN = NativeModules.RN;</div><div class="line"></div><div class="line"><span class="keyword">const</span> RNEvent = <span class="keyword">new</span> NativeEventEmitter(RN);</div><div class="line"></div><div class="line"><span class="keyword">var</span> subscription = RNEvent.addListener(</div><div class="line">    <span class="string">'textChange'</span>,</div><div class="line">    (result) =&gt; alert(result.text)</div><div class="line">);</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p>参考链接:<br><a href="http://facebook.github.io/react-native/releases/next/docs/native-modules-ios.html" target="_blank" rel="external">官网</a><br><a href="http://reactnative.cn/docs/next/native-modules-ios.html#content" target="_blank" rel="external">中文官网</a><br><a href="https://github.com/facebook/react-native/issues/8714" target="_blank" rel="external">发送事件</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React Native API]]></title>
      <url>http://lionwy.github.io/React-Native-API/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1929911-434f614e7eba73a9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="AppRegistry"><a href="#AppRegistry" class="headerlink" title="AppRegistry"></a>AppRegistry</h2><blockquote>
<p>AppRegistry是JS运行所有React Native应用的入口。</p>
</blockquote>
<p>最常用的是：注册根组件<br><code>registerComponent(appKey, getComponentFunc)</code><br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AppRegistry.registerComponent(<span class="string">'Test'</span>, <span class="function"><span class="params">()</span> =&gt;</span> SampleComponent);</div></pre></td></tr></table></figure></p>
<h2 id="AsyncStorage"><a href="#AsyncStorage" class="headerlink" title="AsyncStorage"></a>AsyncStorage</h2><blockquote>
<p>异步存储读取</p>
</blockquote>
<p>(第三方的)<a href="https://github.com/sunnylqm/react-native-storage/blob/master/README-CHN.md" target="_blank" rel="external">react-native-storage
</a></p>
<h2 id="AlertIOS"><a href="#AlertIOS" class="headerlink" title="AlertIOS"></a>AlertIOS</h2><ol>
<li><p><code>static alert(title, message?, callbackOrButtons?)</code> </p>
<ul>
<li>callbackOrButtons:一个函数func<code>（（）=&gt; void）</code>或者button数组 <code>ButtonsArray</code><ul>
<li>默认情况下，<code>Cancel</code>和<code>OK</code>, func是点OK的方法</li>
</ul>
</li>
<li><p>ButtonsArray: 对象数组，有以下几个参数</p>
<ul>
<li>text:</li>
<li>onPress:</li>
<li>style: AlertButtonStyle<ul>
<li>default</li>
<li>cancel</li>
<li>destructive</li>
</ul>
</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.customButtons = [&#123;</div><div class="line">      <span class="built_in">text</span>: <span class="string">'Custom OK'</span>,</div><div class="line">      onPress: <span class="keyword">this</span>.saveResponse(按钮方法)</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">      <span class="built_in">text</span>: <span class="string">'Custom cancel'</span>,</div><div class="line">      style: <span class="string">'cancel'</span>,（<span class="built_in">default</span>/cancel/destructive）</div><div class="line">  &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>static prompt(title, message?, callbackOrButtons?, type?, defaultValue?)</code> 有输入框的提示，可以用于提示用户名/密码输入</p>
<ul>
<li><p>type: AlertType</p>
<ul>
<li>default</li>
<li>plain-text</li>
<li>secure-text</li>
<li>login-password</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AlertIOS.prompt(</div><div class="line">        <span class="string">'input your password'</span>, </div><div class="line">        <span class="literal">null</span>, </div><div class="line">        <span class="keyword">this</span>.customButtons, </div><div class="line">        <span class="string">'login-password'</span>, </div><div class="line">        <span class="string">'userName'</span>)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="ActionSheetIOS"><a href="#ActionSheetIOS" class="headerlink" title="ActionSheetIOS"></a>ActionSheetIOS</h2><ol>
<li><p><code>static showActionSheetWithOptions(options, callback)</code></p>
<ul>
<li><code>options</code> 字符串数组,button title</li>
<li><code>cancelButtonIndex</code></li>
<li><code>destructiveButtonIndex</code></li>
<li><code>title</code></li>
<li><code>message</code></li>
<li><code>tintColor</code></li>
<li><p><code>callBack</code> 回调func，</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">showActionSheet</span> = <span class="params">()</span>=&gt;</span> &#123;</div><div class="line">   ActionSheetIOS.showActionSheetWithOptions(&#123;</div><div class="line">       options: BUTTONS,</div><div class="line">       cancelButtonIndex: CANCEL_INDEX,</div><div class="line">       destructiveButtonIndex: DESTRUCTIVE_INDEX,</div><div class="line">       tintColor: <span class="string">'green'</span>,</div><div class="line">       title: <span class="string">'action sheet title'</span>,</div><div class="line">       message: <span class="string">'message'</span></div><div class="line">   &#125;,</div><div class="line"></div><div class="line">   <span class="function"><span class="params">(buttonIndex)</span> =&gt;</span> &#123;</div><div class="line">       <span class="keyword">this</span>.setState(&#123;clicked: BUTTONS[buttonIndex]&#125;);</div><div class="line">   &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>static showShareActionSheetWithOptions(options, failureCallback, successCallback)</code> 分享弹出框</p>
<ul>
<li><code>url</code></li>
<li><code>message</code></li>
<li><code>subject</code> 主题</li>
<li><p><code>excludedActivityTypes</code> 弹出框中不显示的活动</p>
<figure class="highlight moonscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">showShareActionSheet</span> = <span class="params">()</span>=&gt;</span> &#123;</div><div class="line">       UIManager.takeSnapshot(<span class="string">'window'</span>).<span class="keyword">then</span>(<span class="function"><span class="params">(uri)</span>=&gt;</span> &#123;</div><div class="line">           ActionSheetIOS.showShareActionSheetWithOptions(&#123;</div><div class="line">               <span class="name">url</span>: uri,</div><div class="line">               <span class="name">message</span>: <span class="string">'message to go with shared url'</span>,</div><div class="line">   	        <span class="name">subject</span>: <span class="string">'a subject to go in the email heading'</span>,</div><div class="line">               <span class="name">excludedActivityTypes</span>: [</div><div class="line">                   <span class="string">'com.baidu.www'</span></div><div class="line">               ]</div><div class="line">           &#125;,</div><div class="line">           <span class="function"><span class="params">(<span class="built_in">error</span>)</span> =&gt;</span> alert(<span class="built_in">error</span>),</div><div class="line">           <span class="function"><span class="params">(success, method)</span> =&gt;</span> &#123;</div><div class="line">               var text;</div><div class="line">               <span class="keyword">if</span> (success) &#123;</div><div class="line">                   text = <span class="string">'Shared via $&#123;method&#125;'</span>;</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   text = <span class="string">'You didn\'t share'</span>;</div><div class="line">               &#125;</div><div class="line">               this.setState(&#123;text&#125;);</div><div class="line">           &#125;);</div><div class="line">       &#125;).catch(<span class="function"><span class="params">(<span class="built_in">error</span>)</span> =&gt;</span> alert(<span class="built_in">error</span>));</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="PixelRatio"><a href="#PixelRatio" class="headerlink" title="PixelRatio"></a>PixelRatio</h2><blockquote>
<p>相当于iOS中的<code>[UIScreen mainScreen].scale</code></p>
</blockquote>
<ol>
<li><p><code>static get()</code> </p>
<ul>
<li>PixelRatio.get() === 1<ul>
<li>mdpi Android devices (160 dpi)</li>
</ul>
</li>
<li>PixelRatio.get() === 1.5<ul>
<li>hdpi Android devices (240 dpi)</li>
</ul>
</li>
<li>PixelRatio.get() === 2<ul>
<li>iPhone 4, 4S</li>
<li>iPhone 5, 5c, 5s</li>
<li>iPhone 6</li>
<li>xhdpi Android devices (320 dpi)</li>
</ul>
</li>
<li>PixelRatio.get() === 3<ul>
<li>iPhone 6 plus</li>
<li>xxhdpi Android devices (480 dpi)</li>
</ul>
</li>
<li>PixelRatio.get() === 3.5<ul>
<li>Nexus 6</li>
</ul>
</li>
</ul>
</li>
<li><p><code>static getPixelSizeForLayoutSize(layoutSize)</code><br>将布局尺寸，转化为像素尺寸。返回的是整数数值</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> <span class="built_in">image</span> = getImage(&#123;</div><div class="line">	  <span class="built_in">width</span>: PixelRatio.getPixelSizeForLayoutSize(<span class="number">200</span>),</div><div class="line">	  <span class="built_in">height</span>: PixelRatio.getPixelSizeForLayoutSize(<span class="number">100</span>),</div><div class="line">&#125;);</div><div class="line">&lt;Image source=&#123;<span class="built_in">image</span>&#125; <span class="built_in">style</span>=&#123;&#123;<span class="built_in">width</span>: <span class="number">200</span>, <span class="built_in">height</span>: <span class="number">100</span>&#125;&#125; /&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="AppState"><a href="#AppState" class="headerlink" title="AppState"></a>AppState</h2><blockquote>
<p>常用于推送通知</p>
</blockquote>
<ol>
<li><code>currentState</code> 当前状态</li>
<li><code>addEventListener(type, handler)</code>  添加事件监听</li>
<li><code>removeEventListener(type, handler)</code>移除事件监听</li>
</ol>
<h2 id="NetInfo"><a href="#NetInfo" class="headerlink" title="NetInfo"></a>NetInfo</h2><blockquote>
<p>获取网络状态和类型，用时再<a href="http://facebook.github.io/react-native/docs/netinfo.html" target="_blank" rel="external">查找</a></p>
</blockquote>
<h2 id="CameralRoll"><a href="#CameralRoll" class="headerlink" title="CameralRoll"></a>CameralRoll</h2><blockquote>
<p>提供相册相关的功能</p>
</blockquote>
<ul>
<li><p><code>static saveToCameraRoll(tag, type?)</code> 存储</p>
<ul>
<li><p>type: 只能是<code>photo</code> 或者<code>video</code></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">CameraRoll</span><span class="selector-class">.saveToCameraRoll</span>(imgURL + img1, <span class="string">'photo'</span>)</div><div class="line">  <span class="selector-class">.then</span>((url)=&gt;&#123;</div><div class="line">      console<span class="selector-class">.log</span>(<span class="string">'-----'</span> + url);</div><div class="line">      var photos =_that<span class="selector-class">.state</span><span class="selector-class">.photos</span>;</div><div class="line">      photos<span class="selector-class">.unshift</span>(url);</div><div class="line">      <span class="selector-tag">_that</span><span class="selector-class">.setState</span>(&#123;</div><div class="line">          <span class="attribute">photos</span>: photos</div><div class="line"></div><div class="line">      &#125;);</div><div class="line">      AlertIOS<span class="selector-class">.alert</span>(<span class="string">'图片1保存成功'</span>);</div><div class="line">  &#125;)</div><div class="line">  <span class="selector-class">.catch</span>((error)=&gt; &#123;</div><div class="line">      AlertIOS<span class="selector-class">.alert</span>(<span class="string">'图片1保存失败'</span> + error);</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>static getPhotos(params)</code> 获取图片</p>
<ul>
<li>params 具体<a href="https://github.com/facebook/react-native/blob/master/Libraries/CameraRoll/CameraRoll.js#L46" target="_blank" rel="external">这里</a></li>
</ul>
</li>
<li><p><a href="https://github.com/lwansbrough/react-native-camera" target="_blank" rel="external">react-native-camera
</a></p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fetchParams =&#123;</div><div class="line">    first: <span class="number">4</span>,</div><div class="line">    groupTypes: <span class="string">'All'</span>,</div><div class="line">    assetType: <span class="string">'Photos'</span>,</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> imgURL = <span class="string">'http://vczero.github.io/lvtu/img/'</span>;</div><div class="line"></div><div class="line">componentDidMount() &#123;</div><div class="line">   <span class="keyword">var</span> _that = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">   CameraRoll.getPhotos(fetchParams)</div><div class="line">   .then((<span class="keyword">data</span>)=&gt; &#123;</div><div class="line">       console.log(<span class="string">'===='</span> + <span class="keyword">data</span>.edges);</div><div class="line">       <span class="keyword">var</span> edges = <span class="keyword">data</span>.edges;</div><div class="line">       <span class="keyword">var</span> photos = [];</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> edges)&#123;</div><div class="line">           photos.push(edges[i].node.image.uri);</div><div class="line">       &#125;</div><div class="line">       _that.setState(&#123;</div><div class="line">           photos: photos</div><div class="line">       &#125;);</div><div class="line">   &#125;, ()=&gt; &#123;</div><div class="line">       alert(<span class="string">'图片获取失败'</span>);</div><div class="line">   &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Vibration"><a href="#Vibration" class="headerlink" title="Vibration"></a>Vibration</h2><blockquote>
<p>控制设备震动</p>
</blockquote>
<h2 id="Geolocation"><a href="#Geolocation" class="headerlink" title="Geolocation"></a>Geolocation</h2><blockquote>
<p>处理位置信息</p>
</blockquote>
<ol>
<li>iOS<ul>
<li>plist 添加<code>NSLocationWhenInUseUsageDescription</code>字段</li>
<li>使用<code>react-native init</code>创建的项目，默认开启定位功能</li>
</ul>
</li>
<li><p>Android</p>
<ul>
<li>AndroidManifest.xml 添加<code>&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;</code></li>
</ul>
</li>
<li><p><code>static getCurrentPosition(geo_success, geo_error?, geo_options?)</code> 获取当前位置信息</p>
<ul>
<li>geo_options<ul>
<li><code>enableHighAccuracy</code> ： bool， 是否高精度</li>
<li><code>timeout</code> 超时时间</li>
<li><code>maximumAge</code> 多久之后再次获取，即重复获取时间间隔</li>
</ul>
</li>
</ul>
</li>
<li><code>static watchPosition(success, error?, options?)</code> 监听位置变换信息</li>
<li><code>static clearWatch(watchID)</code></li>
<li><code>static stopObserving()</code></li>
</ol>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">componentDidMount() &#123;</div><div class="line">   navigator.geolocation.getCurrentPosition(</div><div class="line">       <span class="function"><span class="params">(position)</span> =&gt;</span> &#123;</div><div class="line">           var initialPosition = JSON.stringify(position);</div><div class="line">           <span class="keyword">this</span>.setState(&#123;initialPosition&#125;);</div><div class="line">       &#125;,</div><div class="line">       <span class="function"><span class="params">(error)</span> =&gt;</span> alert(JSON.stringify(error)),</div><div class="line">       &#123;enableHighAccuracy: <span class="literal">true</span>, timeout: <span class="number">20000</span>, maximumAge: <span class="number">1000</span>&#125;</div><div class="line">   );</div><div class="line">   <span class="keyword">this</span>.watchID = navigator.geolocation.watchPosition(<span class="function"><span class="params">(position)</span> =&gt;</span> &#123;</div><div class="line">       var lastPosition = JSON.stringify(position);</div><div class="line">       <span class="keyword">this</span>.setState(&#123;lastPosition&#125;);</div><div class="line">   &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数据请求"><a href="#数据请求" class="headerlink" title="数据请求"></a>数据请求</h2><blockquote>
<p><code>fetch</code>封装程度更好</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">_postRequest(url, data, callback) &#123;</div><div class="line">   var opt = &#123;</div><div class="line">       method: <span class="string">'POST'</span>,</div><div class="line">       headers: &#123;</div><div class="line">           <span class="string">'Accept'</span>: <span class="string">'application/json'</span>,</div><div class="line">           <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</div><div class="line">       &#125;,</div><div class="line">       body: JSON.stringify(data)</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   fetch(url, opt)</div><div class="line">   .<span class="keyword">then</span>(<span class="function"><span class="params">(response)</span> =&gt;</span> response.json())</div><div class="line">   .<span class="keyword">then</span>(<span class="function"><span class="params">(responseJson)</span>=&gt;</span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(responseJson);</div><div class="line">       callback(responseJson);</div><div class="line"></div><div class="line">   &#125;)</div><div class="line">   .<span class="keyword">catch</span>(<span class="function"><span class="params">(error)</span>=&gt;</span>&#123;</div><div class="line">       <span class="built_in">console</span>.warn(error);</div><div class="line">   &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[记React Native 组件]]></title>
      <url>http://lionwy.github.io/%E8%AE%B0React-Native-%E7%BB%84%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1929911-4155623a1eb9a829.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="茫茫多"></p>
<h2 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局:"></a>Flex 布局:</h2><ol>
<li><p><code>flexDirection</code></p>
</li>
<li><p><code>alignItems</code></p>
</li>
<li><code>justifyContent</code></li>
</ol>
<h2 id="ActivityIndicator"><a href="#ActivityIndicator" class="headerlink" title="ActivityIndicator:"></a>ActivityIndicator:</h2><ol>
<li><p><code>animating</code></p>
</li>
<li><p><code>color</code></p>
</li>
<li><code>size</code> (small, large)  Android 情况下可以输入 number</li>
<li><code>hidesWhenStopped</code> (iOS，当停止时，是否隐藏，默认是true)</li>
</ol>
<h2 id="Button"><a href="#Button" class="headerlink" title="Button:"></a>Button:</h2><ol>
<li><p><code>color</code></p>
</li>
<li><p><code>disable</code></p>
</li>
<li><code>title</code></li>
</ol>
<ul>
<li><code>onPress</code></li>
</ul>
<h2 id="DatePickerIOS"><a href="#DatePickerIOS" class="headerlink" title="DatePickerIOS:"></a>DatePickerIOS:</h2><ol>
<li><p><code>date</code></p>
</li>
<li><p><code>maximumDate</code></p>
</li>
<li><code>minimumDate</code></li>
<li><code>minuteInterval</code>(分钟单位， 1，2，3，4，5，6，10，12，15，20，30)</li>
<li><code>mode</code>（date, time, datetime）</li>
<li><code>timeZoneOffsetInMinutes</code></li>
</ol>
<ul>
<li><code>onDateChange</code></li>
</ul>
<h2 id="Text"><a href="#Text" class="headerlink" title="Text:"></a>Text:</h2><ol>
<li><p><code>numberOfLines</code> </p>
</li>
<li><p><code>onPress</code></p>
</li>
<li><code>textAlign</code></li>
<li>后续的样式会覆盖之前的样式</li>
</ol>
<h2 id="TextInput"><a href="#TextInput" class="headerlink" title="TextInput:"></a>TextInput:</h2><ol>
<li><p><code>autoCapitalize</code>  转换大写</p>
<ul>
<li>characters 所有字符</li>
<li>words 每个单词的首字符</li>
<li>sentences 每句话的首字符</li>
<li>none</li>
</ul>
</li>
<li><p><code>autoCorrect</code> 拼写自动修正</p>
</li>
<li><p><code>autoFocus</code> 自动响应</p>
</li>
<li><p><code>defaultValue</code></p>
</li>
<li><code>editable</code></li>
<li><code>keyboardType</code></li>
<li><code>maxLength</code></li>
<li><code>multiline</code></li>
<li><code>placeholder</code></li>
<li><code>placeholderTextColor</code></li>
<li><code>secureTextEntry</code></li>
<li><code>value</code></li>
<li><p><code>clearButtonMode</code> (iOS)</p>
<ul>
<li>never</li>
<li>while-editing</li>
<li>unless-editing</li>
<li>always</li>
</ul>
</li>
<li><p><code>keyboardAppearance</code>(iOS)</p>
<ul>
<li>default/light/dark</li>
</ul>
</li>
<li><p><code>returnKeyType</code> </p>
</li>
</ol>
<ul>
<li><code>onChange</code></li>
<li><code>onChangeText</code></li>
<li><code>onEndEditing</code>    </li>
<li><code>onSubmitEditing</code></li>
</ul>
<h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView:"></a>ListView:</h2><ul>
<li><p><code>dataSource</code> </p>
</li>
<li><p><code>renderRow</code></p>
</li>
</ul>
<h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator:"></a>Navigator:</h2><ul>
<li><code>initialRoute</code><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">initialRoute=&#123;&#123;</div><div class="line">    		title: <span class="string">'导航'</span>,</div><div class="line">        	<span class="built_in">index</span>: <span class="number">0</span>,</div><div class="line">     		componen<span class="variable">t:</span> MainView /*导航器的视图页面*/</div><div class="line">     		param<span class="variable">s:</span> &#123;</div><div class="line">     		</div><div class="line">     		&#125;</div><div class="line"></div><div class="line">     &#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>renderScene</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">renderScene=&#123;(route, navigator) =&gt; &#123;</div><div class="line">        	<span class="keyword">let</span> Component = route.component;</div><div class="line">        	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span></span></span></div><div class="line">                 &#123;<span class="attr">...route.params</span>&#125;</div><div class="line">                 <span class="attr">navigator</span>=<span class="string">&#123;navigator&#125;</span></div><div class="line">		/&gt;</div><div class="line"></div><div class="line">	&#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="NavigatorIOS："><a href="#NavigatorIOS：" class="headerlink" title="NavigatorIOS："></a>NavigatorIOS：</h2><ol>
<li><p><code>initialRoute</code></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> <span class="string">component:</span></div><div class="line"><span class="number">2.</span> <span class="string">title:</span></div><div class="line"><span class="number">3.</span> <span class="string">titleImage:</span> require(<span class="string">'./img/icon1.png'</span>)</div><div class="line"><span class="number">4.</span> <span class="string">passProps:</span>参数传递，跟上面区分</div><div class="line"><span class="number">5.</span> <span class="string">backButtonTitle:</span></div><div class="line"><span class="number">6.</span> <span class="string">backButtonIcon:</span> </div><div class="line"><span class="number">7.</span> <span class="string">leftButtonTitle:</span></div><div class="line"><span class="number">8.</span> <span class="string">onLeftButtonPress:</span></div><div class="line"><span class="number">9.</span> <span class="string">navigationBarHidden:</span></div><div class="line"><span class="number">10.</span> <span class="string">shadowHidden:</span></div><div class="line"><span class="number">11.</span> <span class="string">tintColor:</span></div><div class="line"><span class="number">12.</span> <span class="string">titleTextColor:</span></div><div class="line"><span class="number">13.</span> <span class="string">translucent:</span></div><div class="line"></div><div class="line"></div><div class="line">&#123;</div><div class="line"><span class="symbol">	leftButtonTitle:</span> <span class="string">'back'</span>,</div><div class="line"><span class="symbol">	rightButtonIcon:</span> (require(<span class="string">'./img/left.png'</span>)),</div><div class="line"><span class="symbol">	onLeftButtonPress:</span> ()=&gt;&#123;</div><div class="line">	     <span class="keyword">this</span>.props.navigator.pop()</div><div class="line">	 &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>interactivePopGestureEnabled</code></p>
</li>
<li><code>navigationBarHidden</code>:</li>
<li><code>shadowHidden</code>:</li>
<li><code>tintColor</code>:</li>
<li><code>titleTextColor</code>:</li>
<li><code>translucent</code>:</li>
</ol>
<ul>
<li>push(route)</li>
<li>popN(number)</li>
<li>pop()</li>
<li>popToTop()</li>
</ul>
<h2 id="state"><a href="#state" class="headerlink" title="state:"></a>state:</h2><ul>
<li><p><code>this.state = { };</code></p>
</li>
<li><p><code>this.setState({});</code></p>
</li>
</ul>
<h2 id="Image"><a href="#Image" class="headerlink" title="Image:"></a>Image:</h2><ol>
<li><p><code>resizeMode</code>：</p>
<ul>
<li>cover(覆盖容器)</li>
<li>contain（适合容器）</li>
<li>stretch（充满）</li>
</ul>
</li>
<li><p><code>source</code>:</p>
<ul>
<li><p>使用静态图片时，不需要指定大小style</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Image <span class="keyword">source</span> = &#123;<span class="keyword">require</span>(<span class="string">'./icon.png'</span>)&#125; /&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>js 使用app中的图片资源需要设置大小style</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Image source=&#123;&#123;uri: <span class="string">'app_icon'</span>&#125;&#125; style=&#123;&#123;width: <span class="number">40</span>, height: <span class="number">40</span>&#125;&#125; /&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>网络图片同上，也需要设置size</p>
</li>
</ul>
</li>
<li><p><code>defaultSource</code>， iOS上的placeholder </p>
</li>
<li><p><code>onProgress</code> iOS 监听下载进度</p>
</li>
</ol>
<h2 id="TabBarIOS"><a href="#TabBarIOS" class="headerlink" title="TabBarIOS:"></a>TabBarIOS:</h2><ol>
<li><p><code>barTintColor</code> bar背景</p>
</li>
<li><p><code>tintColor</code> 标签被选中之后的颜色</p>
</li>
<li><code>unselectedTintColor</code> 标签未选中的颜色(待定)</li>
<li><code>translucent</code> 是否半透明化</li>
</ol>
<h3 id="TabBarIOS-Item"><a href="#TabBarIOS-Item" class="headerlink" title="TabBarIOS.Item:"></a>TabBarIOS.Item:</h3><ol>
<li><p><code>badge</code> </p>
</li>
<li><p><code>title</code></p>
</li>
<li><p><code>renderAsOriginal</code> 配合icon使用</p>
</li>
<li><code>selectedIcon</code></li>
<li><code>icon</code> 图标，当设置<code>systemIcon</code>时，<code>icon</code>无效果</li>
<li><code>systemIcon</code> (‘bookmarks’, ‘contacts’, ‘downloads’, ‘favorites’, ‘featured’, ‘history’, ‘more’, ‘most-recent’, ‘most-viewed’, ‘recents’, ‘search’, ‘top-rated’)</li>
<li><p><code>selected</code> 当前标签选中状态，</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">selected=&#123;this.<span class="keyword">state</span>.selectedTab === '当前tab'&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>onPress</code> </p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;TabBarIOS.Item</div><div class="line">     icon=&#123;<span class="built_in">require</span>(<span class="string">'./img/icon2.png'</span>)&#125;</div><div class="line">     selectedIcon=&#123;<span class="built_in">require</span>(<span class="string">'./img/icon3.png'</span>)&#125;</div><div class="line">     renderAsOriginal</div><div class="line">     title=<span class="string">'More'</span></div><div class="line">     selected=&#123;<span class="keyword">this</span>.state.selectedTab === <span class="string">'greenTab'</span>&#125;</div><div class="line">     onPress=&#123;()=&gt;&#123;</div><div class="line">         <span class="keyword">this</span>.setState(&#123;</div><div class="line">             selectedTab: <span class="string">'greenTab'</span>,</div><div class="line">             presses: <span class="keyword">this</span>.state.presses + <span class="number">1</span></div><div class="line">         &#125;);</div><div class="line">     &#125;&#125; &gt;</div><div class="line"> <span class="xml"><span class="tag">&lt;/<span class="name">TabBarIOS.Item</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p><a href="https://github.com/LionWY/React-Native-Test" target="_blank" rel="external">Test地址</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[坎坷的RN之路]]></title>
      <url>http://lionwy.github.io/%E5%9D%8E%E5%9D%B7%E7%9A%84RN%E4%B9%8B%E8%B7%AF/</url>
      <content type="html"><![CDATA[<h2 id="RN-初识"><a href="#RN-初识" class="headerlink" title="RN 初识"></a>RN 初识</h2><p><img src="http://upload-images.jianshu.io/upload_images/1929911-1645f688d77860fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>看到这张图可能瞬间就对RN无感了，两周一个版本，哪怕改动不大，也足以让人崩溃了，所以你需要很大的勇气来接触它，甚至有兴趣去学习它。</p>
<h2 id="Android-？-Java-？-RN"><a href="#Android-？-Java-？-RN" class="headerlink" title="Android ？ Java ？ RN"></a>Android ？ Java ？ RN</h2><p>其实最近挺崩溃的，iOS当前形势都有目共睹，因此哪怕对现在公司不怎么满意，也没有太大的想法。然而就在我发上篇博客的周五下午，领导找到我，问，能学Android吗？不能就走吧，当时我是懵的，下意识的点了点头。然后安卓的小伙伴就走了。</p>
<p>新的一周接过了小伙伴的电脑，开始琢磨Android。还好以前学过Java，不过过去这么些年也就处于能看懂的地步。还是找找教程吧，当时有三个方向<a href="https://developer.android.com/index.html" target="_blank" rel="external">官网</a>必不可少，<a href="https://book.douban.com/subject/25942191/" target="_blank" rel="external">第一行代码-Android</a>貌似很不错，<a href="https://book.douban.com/subject/3770255/" target="_blank" rel="external">Google Android 开发入门与实战</a>也有相当高的人气，结果。。我都放弃了。也是有自己的一点私心，觉得没必要那么着急的去实战写Android（公司其实也没那么着急，内心也有点点抗拒），还是要把基础学好了，学好Java，总要比会点点Android要好的多。而且，后台大多是Java写的，内心深处也想着学好Java以后学后台也有益处，（移动端也要会后台，大势所趋）目的明确之后就开始了Java的“温故而知新”之旅。</p>
<p>也许是新鲜感，也许真的有兴趣，接下来的两天，从来没有过的开心，写个<code>sysout</code>都能有一种幸福感。。。感觉Java比大学时候简单太多了，其实在你真正熟悉一门语言之后，再学习第二门语言，会容易很多。幸福的日子总是这么短暂，就在第三天，不知道领导听了谁的耳边风（领导不怎么懂技术，刚好招了个react大神），觉得<code>React</code>要一统天下，<code>iOS</code>、<code>Android</code>都会被淘汰，我就被打发去学<code>react native</code>，我的内心真是….</p>
<h2 id="RN是什么"><a href="#RN是什么" class="headerlink" title="RN是什么"></a>RN是什么</h2><p><strong>暂时</strong>离开Java（我还会回来的），我还真挺舍不得的，奈何，拿人钱财与人消灾，老老实实学<code>react native</code>吧。我的出路到底在哪儿，有那么一丝悲凉。。。</p>
<p><code>React Native</code> 到底是什么，两周接触下来，也有了自己粗浅的理解。<strong><em>RN就是实现Native的另一种方式。</em></strong><br>说起RN，就少不了H5，然而H5在移动端貌似已经越来越少见了（是这样吧），究其原因<strong>性能、体验不佳</strong>，而RN要想避免这个问题，就必须<code>NATIVE</code>。因此RN的组件（components）几乎都是仿制native的控件，属性也相差无几，因此你学习RN的同时也是复习iOS的过程。表面RN是用JS写自己的组件，实际运行过程中通过桥接（bridge）调用的是native的控件，RN调用的还是native的控件，native的控件。</p>
<h2 id="学习RN"><a href="#学习RN" class="headerlink" title="学习RN"></a>学习RN</h2><p>学习react native 只推荐两个网站，<a href="http://facebook.github.io/react-native/" target="_blank" rel="external">官网</a>还有<a href="http://reactnative.cn/" target="_blank" rel="external">中文网</a>，其他的仅供参考。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从源码看runLoop]]></title>
      <url>http://lionwy.github.io/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8BrunLoop/</url>
      <content type="html"><![CDATA[<blockquote>
<p>源码比文字更令人深刻</p>
</blockquote>
<p>版本： CF-1151.16</p>
<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW12" target="_blank" rel="external">官方文档</a></p>
<p><a href="https://developer.apple.com/reference/corefoundation" target="_blank" rel="external">相关API</a></p>
<p><a href="http://opensource.apple.com/tarballs/CF/CF-1151.16.tar.gz" target="_blank" rel="external">源码下载</a></p>
<p>为了文章简洁，只摘抄部分主要的代码<br>源码详细介绍在<a href="https://github.com/LionWY/SourceCodeStorage/blob/master/Demo/RunLoopTest/RunLoopTest/CF-1151.16/CFRunLoop.c" target="_blank" rel="external">这里</a></p>
<p><img src="http://oeb4c30x3.bkt.clouddn.com/runLoop.jpg" alt=""></p>
<h2 id="一、邂逅runLoop"><a href="#一、邂逅runLoop" class="headerlink" title="一、邂逅runLoop"></a>一、邂逅runLoop</h2><p>应该是一个美丽的下午，在一场面试上，遇见了runLoop，可惜擦肩而过。。。</p>
<h2 id="二、认识runLoop"><a href="#二、认识runLoop" class="headerlink" title="二、认识runLoop"></a>二、认识runLoop</h2><hr>
<h3 id="CFRunLoop"><a href="#CFRunLoop" class="headerlink" title="CFRunLoop"></a>CFRunLoop</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</div><div class="line">    pthread_t _pthread;            		 <span class="comment">// runLoop 对应的线程</span></div><div class="line">    </div><div class="line">    __CFPort _wakeUpPort;				<span class="comment">// 用来唤醒runLoop的端口，接收消息，执行CFRunLoopWakeUp方法</span></div><div class="line">    </div><div class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;       <span class="comment">// 集合，所有标记为common的mode的集合</span></div><div class="line">    </div><div class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems;   <span class="comment">// 集合，commonMode的item（observers/sources/timers）的集合</span></div><div class="line">    </div><div class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;      <span class="comment">// 当前runLoop运行的mode</span></div><div class="line">    </div><div class="line">    <span class="built_in">CFMutableSetRef</span> _modes;             <span class="comment">// 集合，mode的集合</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>从源码可以看出一部分内容 ：<br>一个runLoop对象，主要包含一个线程<code>_pthread</code>，一个用来被唤醒的端口<code>_wakeUpPort</code>，一个当前运行的mode<code>_currentMode</code>，以及若干个<code>_modes</code>、<code>_commonModes</code>、<code>_commonModeItems</code>。<br>runLoop有很多mode，即<code>_modes</code>，但是只有一个<code>_currentMode</code>，runLoop一次只能运行在一个mode下，不可能在多个mode下同时运行。</p>
<h3 id="CFRunLoopMode"><a href="#CFRunLoopMode" class="headerlink" title="CFRunLoopMode"></a>CFRunLoopMode</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</div><div class="line">	<span class="built_in">CFStringRef</span> _name;      <span class="comment">// mode的名字，唯一标识</span></div><div class="line">    </div><div class="line">    Boolean _stopped;       <span class="comment">// mode的状态，是否停止</span></div><div class="line">    </div><div class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;  <span class="comment">// sources0 的集合</span></div><div class="line">    </div><div class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;  <span class="comment">// sources1 的集合</span></div><div class="line">    </div><div class="line">    <span class="built_in">CFMutableArrayRef</span> _observers;   <span class="comment">// 存储所有观察者（observers）的数组</span></div><div class="line">    </div><div class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;      <span class="comment">// 存储所有定时器（timers）的数组</span></div><div class="line">    </div><div class="line">    <span class="comment">// 源码中有一段代码，可以看出字典的存储对象</span></div><div class="line">    <span class="comment">// CFDictionarySetValue(rlm-&gt;_portToV1SourceMap, (const void *)(uintptr_t)src_port, rls);</span></div><div class="line">    <span class="built_in">CFMutableDictionaryRef</span> _portToV1SourceMap;  <span class="comment">// 字典 key是__CFPort，value是CFRunLoopSourceRef</span></div><div class="line">    </div><div class="line">    <span class="comment">// __CFPortSetInsert(src_port, rlm-&gt;_portSet);</span></div><div class="line">    __CFPortSet _portSet;           <span class="comment">// 端口的集合</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从mode的组成可以看出来：mode管理了所有的事件（sources/timers/observers），而runLoop是管理mode的</p>
<h3 id="CFRunLoopSource"><a href="#CFRunLoopSource" class="headerlink" title="CFRunLoopSource"></a>CFRunLoopSource</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __CFRunLoopSource &#123;</div><div class="line">	<span class="built_in">CFMutableBagRef</span> _runLoops; 				<span class="comment">// 一个Source 对应多个runLoop</span></div><div class="line">	</div><div class="line">	<span class="keyword">union</span> &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">CFRunLoopSourceContext</span> version0; 	<span class="comment">// source0</span></div><div class="line">        </div><div class="line">        <span class="built_in">CFRunLoopSourceContext1</span> version1; 	<span class="comment">//source1	</span></div><div class="line">        </div><div class="line">    &#125; _context;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"><span class="comment">// source0</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="built_in">CFIndex</span>	version; 	<span class="comment">// 版本号，用来区分是source1还是source0</span></div><div class="line"></div><div class="line">    <span class="keyword">void</span> *	info;</div><div class="line">    </div><div class="line">    <span class="comment">// schedule cancel 是对应的，</span></div><div class="line">    <span class="keyword">void</span>	(*schedule)(<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode);</div><div class="line">    <span class="keyword">void</span>	(*cancel)(<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode);</div><div class="line"></div><div class="line">    <span class="keyword">void</span>	(*perform)(<span class="keyword">void</span> *info); <span class="comment">// 用来回调的指针</span></div><div class="line">   </div><div class="line">&#125; <span class="built_in">CFRunLoopSourceContext</span>;</div><div class="line"></div><div class="line"><span class="comment">// source1</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="built_in">CFIndex</span>	version; 	<span class="comment">// 版本号</span></div><div class="line">    <span class="keyword">void</span> *	info;</div><div class="line">    </div><div class="line"><span class="meta">#if (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)</span></div><div class="line">    mach_port_t	(*getPort)(<span class="keyword">void</span> *info); <span class="comment">// 端口</span></div><div class="line">    <span class="keyword">void</span> *	(*perform)(<span class="keyword">void</span> *msg, <span class="built_in">CFIndex</span> size, <span class="built_in">CFAllocatorRef</span> allocator, <span class="keyword">void</span> *info);</div><div class="line"><span class="meta">#else</span></div><div class="line">    <span class="keyword">void</span> *	(*getPort)(<span class="keyword">void</span> *info);</div><div class="line">    </div><div class="line">    <span class="keyword">void</span>	(*perform)(<span class="keyword">void</span> *info); <span class="comment">// 用来回调的指针</span></div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125; <span class="built_in">CFRunLoopSourceContext1</span>;</div></pre></td></tr></table></figure>
<p>源码中看出来，source0和source1的区别，source1比source0多一个接收消息的端口<code>mach_port_t</code></p>
<h3 id="CFRunLoopObserver"><a href="#CFRunLoopObserver" class="headerlink" title="CFRunLoopObserver"></a>CFRunLoopObserver</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __CFRunLoopObserver &#123;</div><div class="line">   </div><div class="line">    <span class="built_in">CFRunLoopRef</span> _runLoop;         <span class="comment">// observer对应的runLoop, 一一对应</span></div><div class="line">    </div><div class="line">    <span class="built_in">CFIndex</span> _rlCount;              <span class="comment">//  observer当前监测的runLoop数量，主要在安排/移除runLoop的时候用到</span></div><div class="line">    </div><div class="line">    <span class="built_in">CFOptionFlags</span> _activities;      <span class="comment">// observer观测runLoop的状态，枚举类型，</span></div><div class="line">    </div><div class="line">    <span class="built_in">CFIndex</span> _order;                 <span class="comment">// mode使用数组存储observers，根据_order添加observer</span></div><div class="line">    </div><div class="line">    <span class="built_in">CFRunLoopObserverCallBack</span> _callout; </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>_activities</code>状态值：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class="line">    kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>),               <span class="comment">// 即将进入Loop</span></div><div class="line">    kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),        <span class="comment">// runLoop即将处理 Timers</span></div><div class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>),       <span class="comment">// runLoop即将处理 Sources</span></div><div class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>),       <span class="comment">// runLoop即将进入休眠</span></div><div class="line">    kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),        <span class="comment">// runLoop刚从休眠中唤醒</span></div><div class="line">    kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),                <span class="comment">// 即将退出RunLoop</span></div><div class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U       </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="CFRunLoopTimer"><a href="#CFRunLoopTimer" class="headerlink" title="CFRunLoopTimer"></a>CFRunLoopTimer</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __CFRunLoopTimer &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">CFRunLoopRef</span> _runLoop;          <span class="comment">// timer 对应的runLoop</span></div><div class="line">    <span class="built_in">CFMutableSetRef</span> _rlModes;       <span class="comment">// 集合，存放对应的modes，猜测一个timer 可以有多个modes，即可以被加入到多个modes中</span></div><div class="line">    </div><div class="line">    <span class="built_in">CFRunLoopTimerCallBack</span> _callout;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="三、了解runLoop"><a href="#三、了解runLoop" class="headerlink" title="三、了解runLoop"></a>三、了解runLoop</h2><blockquote>
<p>5个类之间的主要方法，来详细了解类之间的相互关系</p>
</blockquote>
<h3 id="CFRunLoopCopyCurrentMode"><a href="#CFRunLoopCopyCurrentMode" class="headerlink" title="CFRunLoopCopyCurrentMode"></a>CFRunLoopCopyCurrentMode</h3><blockquote>
<p> 获取runLoop正在运行的mode（即<code>_currentMode</code>）的name。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFStringRef</span> <span class="built_in">CFRunLoopCopyCurrentMode</span>(<span class="built_in">CFRunLoopRef</span> rl) &#123;</div><div class="line"></div><div class="line">	    <span class="built_in">CFStringRef</span> result = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">       result = (<span class="built_in">CFStringRef</span>)<span class="built_in">CFRetain</span>(rl-&gt;_currentMode-&gt;_name);</div><div class="line">	    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CFRunLoopCopyAllModes"><a href="#CFRunLoopCopyAllModes" class="headerlink" title="CFRunLoopCopyAllModes"></a>CFRunLoopCopyAllModes</h3><blockquote>
<p>返回一个数组，其中包含了runLoop所有定义过的mode（即<code>_modes</code>）的name</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFArrayRef</span> <span class="built_in">CFRunLoopCopyAllModes</span>(<span class="built_in">CFRunLoopRef</span> rl) &#123;</div><div class="line"></div><div class="line">	    <span class="built_in">CFMutableArrayRef</span> array;</div><div class="line">	    </div><div class="line">	    array = <span class="built_in">CFArrayCreateMutable</span>(kCFAllocatorSystemDefault, <span class="built_in">CFSetGetCount</span>(rl-&gt;_modes), &amp;kCFTypeArrayCallBacks);</div><div class="line">	    </div><div class="line">	    <span class="comment">// CFSetApplyFunction 三个参数a，b，c，</span></div><div class="line">	    <span class="comment">// 表示:对a里面的每个对象，都执行一次b方法，b方法的参数是a和c，后面会多次遇到</span></div><div class="line">	    <span class="built_in">CFSetApplyFunction</span>(rl-&gt;_modes, (__CFRunLoopGetModeName), array);</div><div class="line">	    </div><div class="line">	    <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"></div><div class="line">  <span class="comment">// 把mode的name添加进数组array</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRunLoopGetModeName(<span class="keyword">const</span> <span class="keyword">void</span> *value, <span class="keyword">void</span> *context) &#123;</div><div class="line">	    <span class="built_in">CFRunLoopModeRef</span> rlm = (<span class="built_in">CFRunLoopModeRef</span>)value;</div><div class="line">	    <span class="built_in">CFMutableArrayRef</span> array = (<span class="built_in">CFMutableArrayRef</span>)context;</div><div class="line">	    <span class="built_in">CFArrayAppendValue</span>(array, rlm-&gt;_name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CFRunLoopAddCommonMode"><a href="#CFRunLoopAddCommonMode" class="headerlink" title="CFRunLoopAddCommonMode"></a>CFRunLoopAddCommonMode</h3><blockquote>
<p> 向runLoop的commonModes添加一个mode </p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopAddCommonMode</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName) &#123;</div><div class="line">	    </div><div class="line">	    <span class="comment">// 判断 modeName 是否在_commonModes 中，如果已经存在，else中不做任何处理</span></div><div class="line">	    <span class="keyword">if</span> (!<span class="built_in">CFSetContainsValue</span>(rl-&gt;_commonModes, modeName)) &#123;</div><div class="line">	        </div><div class="line">	        <span class="comment">// set 是 runLoop 的 _commonModeItems一份拷贝</span></div><div class="line">	        <span class="built_in">CFSetRef</span> set = rl-&gt;_commonModeItems ? <span class="built_in">CFSetCreateCopy</span>(kCFAllocatorSystemDefault, rl-&gt;_commonModeItems) : <span class="literal">NULL</span>;</div><div class="line">	        <span class="comment">// 1. _commonModes 添加 modeName,</span></div><div class="line">	        <span class="comment">// 可见_commonModes存储的其实是CFStringRef类型的modeName</span></div><div class="line">	        <span class="built_in">CFSetAddValue</span>(rl-&gt;_commonModes, modeName);</div><div class="line">	        </div><div class="line">	        <span class="comment">// 如果items 存在</span></div><div class="line">	        <span class="keyword">if</span> (<span class="literal">NULL</span> != set) &#123;</div><div class="line">	            <span class="built_in">CFTypeRef</span> context[<span class="number">2</span>] = &#123;rl, modeName&#125;;</div><div class="line">	            <span class="comment">// 2. 为modeName对应的Mode添加items中的每个item(timer/source/observer)</span></div><div class="line">	            <span class="comment">// 为set中的每个item，调用一次__CFRunLoopAddItemsToCommonMode方法</span></div><div class="line">	            <span class="built_in">CFSetApplyFunction</span>(set, (__CFRunLoopAddItemsToCommonMode), (<span class="keyword">void</span> *)context);</div><div class="line">	        &#125;</div><div class="line">	    &#125; <span class="keyword">else</span> &#123;</div><div class="line">	    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">// 把一个item添加到指定的mode中</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRunLoopAddItemsToCommonMode(<span class="keyword">const</span> <span class="keyword">void</span> *value, <span class="keyword">void</span> *ctx) &#123;</div><div class="line">    </div><div class="line">	    <span class="built_in">CFTypeRef</span> item = (<span class="built_in">CFTypeRef</span>)value;</div><div class="line">	    </div><div class="line">	    <span class="built_in">CFRunLoopRef</span> rl = ()(((<span class="built_in">CFTypeRef</span> *)ctx)[<span class="number">0</span>]);</div><div class="line">	    </div><div class="line">	    <span class="built_in">CFStringRef</span> modeName = (<span class="built_in">CFStringRef</span>)(((<span class="built_in">CFTypeRef</span> *)ctx)[<span class="number">1</span>]);</div><div class="line">	    </div><div class="line">	    <span class="comment">// 判断item具体是哪种类型，然后进行添加</span></div><div class="line">	    <span class="keyword">if</span> (<span class="built_in">CFGetTypeID</span>(item) == <span class="built_in">CFRunLoopSourceGetTypeID</span>()) &#123;</div><div class="line">	        <span class="built_in">CFRunLoopAddSource</span>(rl, (<span class="built_in">CFRunLoopSourceRef</span>)item, modeName);</div><div class="line">	    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">CFGetTypeID</span>(item) == <span class="built_in">CFRunLoopObserverGetTypeID</span>()) &#123;</div><div class="line">	        <span class="built_in">CFRunLoopAddObserver</span>(rl, (<span class="built_in">CFRunLoopObserverRef</span>)item, modeName);</div><div class="line">	    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">CFGetTypeID</span>(item) == <span class="built_in">CFRunLoopTimerGetTypeID</span>()) &#123;</div><div class="line">	        <span class="built_in">CFRunLoopAddTimer</span>(rl, (<span class="built_in">CFRunLoopTimerRef</span>)item, modeName);</div><div class="line">	    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CFRunLoopAddSource"><a href="#CFRunLoopAddSource" class="headerlink" title="CFRunLoopAddSource"></a>CFRunLoopAddSource</h3><blockquote>
<p>添加一个source到指定的runLoopMode</p>
</blockquote>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName) &#123;	<span class="comment">/* DOES CALLOUT */</span></div><div class="line">	    </div><div class="line">	    <span class="comment">// 声明一个bool值的标识,后续用来source0 添加source</span></div><div class="line">	    Boolean doVer0Callout = <span class="literal">false</span>;</div><div class="line">	    </div><div class="line">	    <span class="comment">// 1. 如果是commonMode，那么commonModes中的所有mode都要更新</span></div><div class="line">	    <span class="keyword">if</span> (modeName == kCFRunLoopCommonModes) &#123;</div><div class="line">		    <span class="comment">/*</span></div><div class="line">		    这里获取rl-&gt;_commonModes并赋值set，如果没有为NULL</div><div class="line">		    同时获取rl-&gt;_commonModeItems，如果不存在就初始化创建</div><div class="line">		    */</div><div class="line">	        <span class="comment">// 1.1 先把 rls 添加进_commonModeItems</span></div><div class="line">	        CFS<span class="function"><span class="title">etAddValue</span>(rl-&gt;</span>_commonModeItems, rls);</div><div class="line">            <span class="comment">// 1.2 为set中其他的mode，添加rls </span></div><div class="line">            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);  </div><div class="line"></div><div class="line">	    &#125;</div><div class="line">	    <span class="comment">// 2. 非commonMode的添加 </span></div><div class="line">	    <span class="keyword">else</span> &#123;</div><div class="line">	        <span class="comment">// 2.1 在runLoop的_modes中查找名字为modeName的mode，找不到会在内部进行初始化创建（true决定是否创建）</span></div><div class="line">	        CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, <span class="literal">true</span>);</div><div class="line">	        </div><div class="line">	        <span class="comment">// 2.2 获取mode的跟source有关的_sources0，_sources1以及端口_portToV1SourceMap</span></div><div class="line">	        <span class="function"><span class="title">if</span> (NULL != rlm &amp;&amp; NULL == rlm-&gt;</span>_sources0) &#123;</div><div class="line">	            <span class="function"><span class="title">rlm</span>-&gt;</span>_sources0 = CFSetCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</div><div class="line">	            <span class="function"><span class="title">rlm</span>-&gt;</span>_sources1 = CFSetCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</div><div class="line">	            <span class="function"><span class="title">rlm</span>-&gt;</span>_portToV1SourceMap = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, NULL, NULL);</div><div class="line">	        &#125;</div><div class="line">	        </div><div class="line">	        </div><div class="line">            <span class="comment">// 2.3 判断rls属于哪种类型，并针对性的添加 </span></div><div class="line">            <span class="comment">// 2.3.1 source0的情况</span></div><div class="line">            <span class="function"><span class="title">if</span> (0 == rls-&gt;</span>_context.version0.version) &#123;</div><div class="line">                CFS<span class="function"><span class="title">etAddValue</span>(rlm-&gt;</span>_sources0, rls);</div><div class="line">                <span class="comment">// 下面这段代码是后面的，放在这里便于理解，source0 有个schedule指针，把rl和rlm关联起来</span></div><div class="line">                <span class="function"><span class="title">rls</span>-&gt;</span>_<span class="function"><span class="title">context</span>.version0.schedule(rls-&gt;</span>_context.version0.info, rl, modeName);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 2.3.2 source1的情况 </span></div><div class="line">            <span class="function"><span class="title">else</span> <span class="keyword">if</span> (1 == rls-&gt;</span>_context.version0.version) &#123;</div><div class="line">                CFS<span class="function"><span class="title">etAddValue</span>(rlm-&gt;</span>_sources1, rls);</div><div class="line">                <span class="comment">// 获取rls的端口</span></div><div class="line">                __CFP<span class="function"><span class="title">ort</span> src_port = rls-&gt;</span>_<span class="function"><span class="title">context</span>.version1.getPort(rls-&gt;</span>_context.version1.info);</div><div class="line">                <span class="comment">// rls和端口一一对应,并存储在mode的字典_portToV1SourceMap中</span></div><div class="line">                CFD<span class="function"><span class="title">ictionarySetValue</span>(rlm-&gt;</span>_portToV1SourceMap, (const void *)(uintptr_t)src_port, rls);</div><div class="line">               <span class="comment">// 把source1 的端口添加进mode的端口集合_portSet中</span></div><div class="line">                __CFP<span class="function"><span class="title">ortSetInsert</span>(src_port, rlm-&gt;</span>_portSet);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 2.4 把rl 加入到rls的_runLoops中，即一个resources可以对应多个runLoop</span></div><div class="line">            <span class="function"><span class="title">if</span> (NULL == rls-&gt;</span>_runLoops) &#123;</div><div class="line">                </div><div class="line">                <span class="function"><span class="title">rls</span>-&gt;</span>_runLoops = CFBagCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeBagCallBacks); <span class="comment">// sources retain run loops!</span></div><div class="line">            &#125;</div><div class="line">            CFB<span class="function"><span class="title">agAddValue</span>(rls-&gt;</span>_runLoops, rl);</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CFRunLoopAddObserver"><a href="#CFRunLoopAddObserver" class="headerlink" title="CFRunLoopAddObserver"></a>CFRunLoopAddObserver</h3><blockquote>
<p>添加rlo到指定的rlm</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CF_EXPORT</span> <span class="keyword">void</span> <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopMode</span> mode);</div></pre></td></tr></table></figure>
<p>内部实现<code>CFRunLoopSource</code>跟差不多，都是根据mode是否commonMode分两种情况，差别在于：</p>
<ul>
<li><p>关联mode：mode有一个数组<code>_observers</code>，添加是根据rlo的<code>_order</code>进行添加的</p>
</li>
<li><p>关联rl：根据<code>_rlCount</code>是否为0。只有当rlo的<code>_rlCount</code>为0时，其<code>_runLoop</code>才是rl。</p>
</li>
</ul>
<h3 id="CFRunLoopAddTimer"><a href="#CFRunLoopAddTimer" class="headerlink" title="CFRunLoopAddTimer"></a>CFRunLoopAddTimer</h3><blockquote>
<p>添加rlt到指定的rlm</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CF_EXPORT</span> <span class="keyword">void</span> <span class="built_in">CFRunLoopAddTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFRunLoopMode</span> mode);</div></pre></td></tr></table></figure>
<p>内部实现同上，区别：</p>
<ol>
<li><p>rlt只能添加到其<code>_runLoop</code>的mode中，如果rl不是其<code>_runLoop</code>，直接返回</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">NULL</span> == rlt-&gt;_runLoop) &#123;</div><div class="line">           rlt-&gt;_runLoop = rl;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl != rlt-&gt;_runLoop) &#123;</div><div class="line">           __CFRunLoopTimerUnlock(rlt);</div><div class="line">           __CFRunLoopModeUnlock(rlm);</div><div class="line">           __CFRunLoopUnlock(rl);</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>rlt有一个变量<code>_rlModes</code>，其存储的是rlt所在的mode的name</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CFS<span class="function"><span class="title">etAddValue</span>(rlt-&gt;</span>_<span class="function"><span class="title">rlModes</span>, rlm-&gt;</span>_<span class="keyword">name</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>rlm有一个变量<code>_timers</code>，其存储timer是根据timer的启动时间，即<code>_fireTSR</code>，进行排序的</p>
</li>
</ol>
<h2 id="四、获取runLoop"><a href="#四、获取runLoop" class="headerlink" title="四、获取runLoop"></a>四、获取runLoop</h2><blockquote>
<p>runLoop跟其所在线程是一一对应的</p>
</blockquote>
<ol>
<li><p>API提供了两个获取runLoop的方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>(<span class="keyword">void</span>) &#123;</div><div class="line">	    <span class="keyword">static</span> <span class="built_in">CFRunLoopRef</span> __main = <span class="literal">NULL</span>; <span class="comment">// no retain needed</span></div><div class="line">	    </div><div class="line">	    <span class="comment">// pthread_main_thread_np() 主线程</span></div><div class="line">	    <span class="keyword">if</span> (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); <span class="comment">// no CAS needed</span></div><div class="line">	    <span class="keyword">return</span> __main;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>(<span class="keyword">void</span>) &#123;</div><div class="line">	   </div><div class="line">	    <span class="built_in">CFRunLoopRef</span> rl = (<span class="built_in">CFRunLoopRef</span>)_CFGetTSD(__CFTSDKeyRunLoop);</div><div class="line">	    <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</div><div class="line">	    <span class="comment">// pthread_self() 当前线程</span></div><div class="line">	    <span class="keyword">return</span> _CFRunLoopGet0(pthread_self());</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>TSD</code>是thread special data，表示线程私有数据，在 C++ 中，全局变量可以被所有线程访问，局部变量只有函数内部可以访问。而 TSD 的作用就是能够在同一个线程的不同函数中被访问。（找到的资料）<br><code>__CFTSDKeyRunLoop</code>是一个枚举类型的关键字。<br><code>pthread_self()</code>可以得知，如果要获取非主线程的runLoop，必须在该线程内部调用<code>CFRunLoopGetCurrent</code>才能获取。</p>
</li>
<li><p>根据线程t获取对应的runLoop</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个内部全局的字典</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> __CFRunLoops = <span class="literal">NULL</span>;</div><div class="line"><span class="built_in">CF_EXPORT</span> <span class="built_in">CFRunLoopRef</span> _CFRunLoopGet0(pthread_t t) &#123;</div><div class="line">    </div><div class="line">	    <span class="comment">// 1. 保证t不为空	   </span></div><div class="line">	    <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT)) &#123;</div><div class="line">	        </div><div class="line">	        t = pthread_main_thread_np();</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    <span class="comment">// 2. 创建全局字典,并存储主线程的runLoop</span></div><div class="line">	    <span class="keyword">if</span> (!__CFRunLoops) &#123;</div><div class="line">	      </div><div class="line">	        <span class="built_in">CFMutableDictionaryRef</span> dict = <span class="built_in">CFDictionaryCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</div><div class="line">	    </div><div class="line">	        <span class="comment">// 通过pthread_main_thread_np()创建CFRunLoopRef类型的mainLoop，内部对其所有变量进行初始化，并且赋值_pthread为pthread_main_thread_np()</span></div><div class="line">	        <span class="built_in">CFRunLoopRef</span> mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</div><div class="line">	        </div><div class="line">	        <span class="comment">// key是主线程的指针， value 是刚创建的mainLoop</span></div><div class="line">	        <span class="built_in">CFDictionarySetValue</span>(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</div><div class="line">	        </div><div class="line">	        <span class="comment">// 比较并交换指针，</span></div><div class="line">	        <span class="comment">// 这里比较第一个参数NULL和第三个参数 (void * volatile *)&amp;__CFRunLoops全局字典，如果相等，系统会自动把第二参数的值赋给第三个参数，</span></div><div class="line">	        <span class="comment">// volatile的作用是 每次取得数值的方式是直接从内存中读取</span></div><div class="line">	        <span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, dict, (<span class="keyword">void</span> * <span class="keyword">volatile</span> *)&amp;__CFRunLoops)) &#123;</div><div class="line">	            <span class="built_in">CFRelease</span>(dict);</div><div class="line">	        &#125;</div><div class="line">	        </div><div class="line">	        <span class="comment">// coreFoundation 要手动管理内存， create 对应 release</span></div><div class="line">	        <span class="built_in">CFRelease</span>(mainLoop);</div><div class="line">	    &#125;</div><div class="line">	    </div><div class="line">	    <span class="comment">// 3. 全局字典已经存在，从中获取对应线程t的runLoop</span></div><div class="line">	    <span class="built_in">CFRunLoopRef</span> loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</div><div class="line">	    </div><div class="line">	    <span class="comment">// 如果获取不到loop，</span></div><div class="line">	    <span class="keyword">if</span> (!loop) &#123;</div><div class="line">	        </div><div class="line">	        <span class="comment">// 根据 t 创建 一个newLoop</span></div><div class="line">	        <span class="built_in">CFRunLoopRef</span> newLoop = __CFRunLoopCreate(t);</div><div class="line">	       </div><div class="line">	        <span class="comment">// 再一次进行获取</span></div><div class="line">	        loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</div><div class="line">	        </div><div class="line">	        <span class="comment">// 如果还不存在，就直接赋值，</span></div><div class="line">	        <span class="keyword">if</span> (!loop) &#123;</div><div class="line">	            <span class="built_in">CFDictionarySetValue</span>(__CFRunLoops, pthreadPointer(t), newLoop);</div><div class="line">	            loop = newLoop;</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	    <span class="comment">// 4. 注册TSD</span></div><div class="line">	    <span class="keyword">if</span> (pthread_equal(t, pthread_self())) &#123;</div><div class="line">	        </div><div class="line">	        <span class="comment">// 注册回调，当线程销毁时，顺便也销毁其对应的 RunLoop</span></div><div class="line">	        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="keyword">void</span> *)loop, <span class="literal">NULL</span>);</div><div class="line">	        </div><div class="line">	        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</div><div class="line">	            _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="keyword">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *))__CFFinalizeRunLoop);</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	    <span class="keyword">return</span> loop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>线程和runLoop是一一对应，保存在一个全局字典里，主线程的runLoop是在初始化字典时已经创建好了，其他线程的runLoop只有在获取的时候才会创建。</p>
<h2 id="五、运行runLoop"><a href="#五、运行runLoop" class="headerlink" title="五、运行runLoop"></a>五、运行runLoop</h2><hr>
<h3 id="CFRunLoopRun"><a href="#CFRunLoopRun" class="headerlink" title="CFRunLoopRun"></a>CFRunLoopRun</h3><blockquote>
<p>默认情况下，运行当前线程的runLoop</p>
</blockquote>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">void</span> <span class="type">CFRunLoopRun</span>(<span class="built_in">void</span>) &#123;	</div><div class="line">    int32_t <span class="literal">result</span>;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="literal">result</span> = <span class="type">CFRunLoopRunSpecific</span>(<span class="type">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1</span>.<span class="number">0</span>e10, <span class="literal">false</span>);</div><div class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != <span class="literal">result</span> &amp;&amp; kCFRunLoopRunFinished != <span class="literal">result</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>源码得知：</p>
<ol>
<li><code>kCFRunLoopDefaultMode</code>，默认情况下，runLoop是在这个mode下运行的，</li>
<li>runLoop的运行主体是一个do..while循环，除非停止或者结束，否则runLoop会一直运行下去</li>
</ol>
<h3 id="CFRunLoopRunInMode"><a href="#CFRunLoopRunInMode" class="headerlink" title="CFRunLoopRunInMode"></a>CFRunLoopRunInMode</h3><blockquote>
<p>在指定的mode下运行当前线程的runLoop</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SInt32 <span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;     </div><div class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法，可以设置runLoop运行在哪个mode下<code>modeName</code>，超时时间<code>seconds</code>，以及是否处理完事件就返回<code>returnAfterSourceHandled</code>。<br>这两个方法实际调用的是同一个方法<code>CFRunLoopRunSpecific</code>，其返回是一个<code>SInt32</code>类型的值，根据返回值，来决定runLoop的运行状况。</p>
<h3 id="CFRunLoopRunSpecific"><a href="#CFRunLoopRunSpecific" class="headerlink" title="CFRunLoopRunSpecific"></a>CFRunLoopRunSpecific</h3><blockquote>
<p>在指定的mode下，运行指定的runLoop</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">SInt32 <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;    </div><div class="line">    <span class="comment">// 根据rl，modeName获取指定的currentMode</span></div><div class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 1. 如果当前mode 不存在，或者当前mode中事件为空，runLoop 结束，返回 kCFRunLoopRunFinished</span></div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</div><div class="line">        <span class="comment">// 声明一个标识did，默认false</span></div><div class="line">        Boolean did = <span class="literal">false</span>;</div><div class="line">        <span class="comment">// did 为 false，返回 kCFRunLoopRunFinished</span></div><div class="line">        <span class="keyword">return</span> did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化一个返回结果，值为kCFRunLoopRunFinished</span></div><div class="line">    int32_t result = kCFRunLoopRunFinished;</div><div class="line"></div><div class="line">	<span class="comment">// 2. kCFRunLoopEntry， 通知observers 即将开始循环</span></div><div class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</div><div class="line">    </div><div class="line">    <span class="comment">// runLoop运行主体</span></div><div class="line">	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</div><div class="line">    </div><div class="line">    <span class="comment">// 3. kCFRunLoopExit， 通知 observers 即将退出循环runLoop</span></div><div class="line">	<span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有3点：</p>
<ol>
<li>kCFRunLoopRunFinished mode中没有事件处理，直接返回</li>
<li>kCFRunLoopEntry     runLoop即将开始运行，通知observers</li>
<li>kCFRunLoopExit runLoop 即将退出，通知observers</li>
</ol>
<h3 id="CFRunLoopRun-1"><a href="#CFRunLoopRun-1" class="headerlink" title="__CFRunLoopRun"></a>__CFRunLoopRun</h3><blockquote>
<p>这里处理了runLoop从开始运行到退出的所有逻辑</p>
</blockquote>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, <span class="keyword">Boolean</span> stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 1. 如果runLoop停止或者runLoopMode为停止状态，直接返回 kCFRunLoopRunStopped</span></div><div class="line">    <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">        <span class="keyword">return</span> kCFRunLoopRunStopped;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</div><div class="line">	rlm-&gt;_stopped = <span class="keyword">false</span>;</div><div class="line">	   <span class="keyword">return</span> kCFRunLoopRunStopped;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 获取主线程用来接收消息的端口</span></div><div class="line">    dispatchPort = _dispatch_get_main_queue_port_4CF();</div><div class="line">   </div><div class="line">    <span class="comment">// 获取执行timers对应的线程的端口</span></div><div class="line">    modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class="line">    </div><div class="line">    <span class="comment">// GCD 管理的定时器，用于实现runLoop的超时机制</span></div><div class="line">    dispatch_source_t timeout_timer = <span class="keyword">NULL</span>;    </div><div class="line">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));</div><div class="line">    </div><div class="line">    <span class="comment">// 处理timer 三种情况 ：timer1 立即超时</span></div><div class="line">    <span class="keyword">if</span> (seconds &lt;= <span class="number">0.0</span>) &#123; <span class="comment">// instant timeout</span></div><div class="line">        seconds = <span class="number">0.0</span>;</div><div class="line">        timeout_context-&gt;termTSR = <span class="number">0</span>ULL;</div><div class="line">        </div><div class="line">        <span class="comment">// timer2 即将超时</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</div><div class="line">			<span class="comment">// 判断在哪个线程中执行</span></div><div class="line">        dispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();</div><div class="line">        </div><div class="line">        timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</div><div class="line"></div><div class="line">        <span class="comment">// 事件一一对应，</span></div><div class="line">        dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</div><div class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</div><div class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(<span class="number">1</span>, ns_at), DISPATCH_TIME_FOREVER, <span class="number">1000</span>ULL);</div><div class="line">        <span class="comment">// 定时器执行</span></div><div class="line">        dispatch_resume(timeout_timer);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// timer3 永不超时</span></div><div class="line">        seconds = <span class="number">9999999999.0</span>;</div><div class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 声明一个标识，默认true，用于执行消息处理</span></div><div class="line">    <span class="keyword">Boolean</span> didDispatchPortLastTime = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">// 声明一个返回值，用于最后的结果返回</span></div><div class="line">    int32_t retVal = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// do..while循环主体，处理runLoop的逻辑</span></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 获取rlm的端口集合</span></div><div class="line">        __CFPortSet waitSet = rlm-&gt;_portSet;</div><div class="line">       <span class="comment">// runLoop设置为可被唤醒的状态</span></div><div class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class="line">        </div><div class="line">        <span class="comment">// 2. kCFRunLoopBeforeTimers runLoop即将处理Timers， 通知observers</span></div><div class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class="line">        <span class="comment">// 3. kCFRunLoopBeforeSources runLoop即将处理Sources，通知observers</span></div><div class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class="line">        </div><div class="line">        <span class="comment">// 4. runLoop开始处理source0事件</span></div><div class="line">        <span class="comment">// sourceHandledThisLoop 是否处理完Source0事件</span></div><div class="line">        <span class="comment">// 内部实现是，只有被标记Signaled的source0事件才会被处理，但在处理之前会去除标记__CFRunLoopSourceUnsetSignaled</span></div><div class="line">        <span class="keyword">Boolean</span> sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</div><div class="line">            <span class="comment">// 处理完Source0之后的回调</span></div><div class="line">            __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 处理完source0事件，且没有超时 poll 为false, </span></div><div class="line">        <span class="comment">// 没有处理完source0 事件，或者超时，为true</span></div><div class="line">        <span class="keyword">Boolean</span> poll = sourceHandledThisLoop || (<span class="number">0</span>ULL == timeout_context-&gt;termTSR);</div><div class="line"></div><div class="line">        <span class="comment">// didDispatchPortLastTime 初始化为true，即第一次循环的时候不会走if方法，</span></div><div class="line">        <span class="comment">// 5. 消息处理，source1 事件，goto 第9步</span></div><div class="line">        <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 从消息缓冲区获取消息</span></div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            <span class="comment">// dispatchPort收到消息，立刻去处理 </span></div><div class="line">            <span class="comment">// dispatchPort 主线程接收消息的端口</span></div><div class="line">            <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="keyword">NULL</span>)) &#123;</div><div class="line">                <span class="comment">// 收到消息，立马去处理</span></div><div class="line">                <span class="keyword">goto</span> handle_msg;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (__CFRunLoopWaitForMultipleObjects(<span class="keyword">NULL</span>, &amp;dispatchPort, <span class="number">0</span>, <span class="number">0</span>, &amp;livePort, <span class="keyword">NULL</span>)) &#123;</div><div class="line">                <span class="keyword">goto</span> handle_msg;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// didDispatchPortLastTime 设置为false，以便进行消息处理</span></div><div class="line">        didDispatchPortLastTime = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 6. kCFRunLoopBeforeWaiting，通知 observers runLoop即将休眠</span></div><div class="line">		<span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class="line">        </div><div class="line">        <span class="comment">// runLoop 休眠</span></div><div class="line">        __CFRunLoopSetSleeping(rl);</div><div class="line">        </div><div class="line">        <span class="comment">// 7.线程进入休眠, 直到被下面某一个事件唤醒。(文档给出的结果：)</span></div><div class="line">	    <span class="comment">// 7.1. 基于 port 的Source1 的事件</span></div><div class="line">	    <span class="comment">// 7.2. Timer 到时间了</span></div><div class="line">	    <span class="comment">// 7.3. RunLoop 启动时设置的最大超时时间到了</span></div><div class="line">	    <span class="comment">// 7.4. 被手动唤醒</span></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="comment">// 从消息缓冲区获取消息</span></div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">				<span class="comment">// 内部调用 mach_msg() 等待接受 waitSet 的消息</span></div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class="line">        &#125; <span class="keyword">while</span> (<span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 设置rl不再等待唤醒</span></div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line">        <span class="comment">// runloop 醒来</span></div><div class="line">        __CFRunLoopUnsetSleeping(rl);</div><div class="line">        </div><div class="line">        <span class="comment">// 8. kCFRunLoopAfterWaiting 已被唤醒，通知observers</span></div><div class="line">	   <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class="line"></div><div class="line">        <span class="comment">// 9. 处理消息</span></div><div class="line">        handle_msg:;</div><div class="line">        <span class="comment">// 设置rl不再等待唤醒</span></div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line"></div><div class="line">        <span class="comment">// 判断 livePort</span></div><div class="line">        <span class="comment">// 9.1 如果不存在</span></div><div class="line">        <span class="keyword">if</span> (MACH_PORT_NULL == livePort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class="line">            <span class="comment">// 9.2 如果是唤醒rl的端口，回到第2步</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == rl-&gt;_wakeUpPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</div><div class="line">            ResetEvent(rl-&gt;_wakeUpPort);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 定时器事件__CFRunLoopDoTimers</span></div><div class="line">        <span class="comment">// 9.3 如果是定时器的端口</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">            <span class="comment">// 处理定时器事件</span></div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 9.4. 如果端口是主线程的端口，直接处理</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);     </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 9.5. 除上述4点之外的端口</span></div><div class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class="line">            </div><div class="line">            <span class="comment">// 从端口收到的消息事件，为source1事件</span></div><div class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (rls) &#123;</div><div class="line"></div><div class="line">                mach_msg_header_t *reply = <span class="keyword">NULL</span>;</div><div class="line">                        <span class="comment">// 处理source1 事件</span></div><div class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">NULL</span> != reply) &#123;</div><div class="line">                		<span class="comment">// 消息处理，</span></div><div class="line">                		<span class="comment">// message.h中，以后有时间会再研究一下</span></div><div class="line">                    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125; </div><div class="line">        <span class="comment">// 10. 返回结果的处理  </span></div><div class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">            <span class="comment">// 10.1 如果事件处理完就返回，并且source处理完成</span></div><div class="line">            retVal = kCFRunLoopRunHandledSource;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class="line">            <span class="comment">// 10.2 超时</span></div><div class="line">            retVal = kCFRunLoopRunTimedOut;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">            <span class="comment">// 10.3 被外部调用者强制停止了</span></div><div class="line">            __CFRunLoopUnsetStopped(rl);</div><div class="line">            retVal = kCFRunLoopRunStopped;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</div><div class="line">            <span class="comment">// 10.4 runLoopMode 状态停止</span></div><div class="line">            rlm-&gt;_stopped = <span class="keyword">false</span>;</div><div class="line">            retVal = kCFRunLoopRunStopped;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class="line">            <span class="comment">// 10.5 source/timer/observer一个都没有了</span></div><div class="line">            retVal = kCFRunLoopRunFinished;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 上述几种情况，会跳出do..while循环，</span></div><div class="line">        <span class="comment">// 除此之外，继续循环</span></div><div class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</div><div class="line">    <span class="keyword">return</span> retVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述2-10就是runLoop运行过程中的循环逻辑，而最终返回的状态有：<code>kCFRunLoopRunFinished</code>、<code>kCFRunLoopRunStopped</code>、<code>kCFRunLoopRunTimedOut</code>以及<code>kCFRunLoopRunHandledSource</code>四种枚举类型</p>
<h2 id="六、总结："><a href="#六、总结：" class="headerlink" title="六、总结："></a>六、总结：</h2><p><strong><em>1. runLoop跟线程一一对应，非主线程的rl只能在其内部获取，runLoop管理rlm和回调block，而rlm存储了所有的事件。</em></strong></p>
<p><strong><em>2. runLoop运行核心就是一个do..while循环，遍历所有事件，有事件处理，无事件休眠，直至达到退出条件。</em></strong></p>
<p><strong><em>3. 以上就是runLoop内部的源码分析，当然会有理解不到位的情况，也留有待解决的问题，万望不吝赐教。</em></strong></p>
<p>参考资料：</p>
<p><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop
</a></p>
<p><a href="http://aaaboom.com/?p=34#wow23" target="_blank" rel="external">RunLoop系列之源码分析
</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW20" target="_blank" rel="external">Run Loops
</a></p>
<p><a href="https://developer.apple.com/reference/corefoundation/1666621-cfrunloop" target="_blank" rel="external">CFRunLoop
</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图片加载之SDWebImage（下）]]></title>
      <url>http://lionwy.github.io/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B9%8BSDWebImage%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>上篇留下的两个入口接着深入分析，图片缓存<code>SDImageCache</code>和图片下载<code>SDWebImageDownloader</code>以及下载操作<code>SDWebImageDownloaderOperation</code></p>
<p><img src="http://oeb4c30x3.bkt.clouddn.com/work.jpg" alt=""></p>
<h2 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h2><blockquote>
<p>SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed asynchronous so it doesn’t add unnecessary latency to the UI.</p>
</blockquote>
<p><code>SDImageCache</code>包含内存缓存以及磁盘缓存。其中，磁盘缓存写入操作是异步执行的，因此不会给UI增加不必要的延迟</p>
<h3 id="查找缓存图片"><a href="#查找缓存图片" class="headerlink" title="查找缓存图片"></a>查找缓存图片</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock;</div></pre></td></tr></table></figure>
<ol>
<li><p>确定<code>key</code>值，实际上就是<code>url.absoluteString</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</div><div class="line"></div><div class="line"><span class="comment">// 如果key不存在，直接返回</span></div><div class="line">   <span class="keyword">if</span> (!key) &#123;</div><div class="line">       <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">           doneBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>第一次在内存中查找：<br>内部其实是通过<code>NSCache</code>来获取和存储的</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIImage *<span class="built_in">image</span> = [self imageFromMemoryCacheForKey:<span class="built_in">key</span>];</div><div class="line">// 方法内部实现：memCache 是 NSCache类型</div><div class="line">// <span class="built_in">return</span> [self.memCache objectForKey:<span class="built_in">key</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>查找到图片之后的操作<br>其中，内存很快，几乎不需要时间，所以不需要一个执行任务，返回<code>operation</code>为nil</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (image) &#123;</div><div class="line">        <span class="built_in">NSData</span> *diskData = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">// 是否是gif图片，实际判断图片对应的数组是否为空</span></div><div class="line">        <span class="keyword">if</span> ([image isGIF]) &#123;</div><div class="line">            <span class="comment">// 在磁盘缓存中根据key获取图片的data</span></div><div class="line">            diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">            <span class="comment">// 查询完成，缓存设置为SDImageCacheTypeMemory</span></div><div class="line">            doneBlock(image, diskData, SDImageCacheTypeMemory);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>内存找不到的情况下，第二次在磁盘中查询<br>磁盘查找比较耗时，所以需要创建一个执行任务<code>operation</code><br><code>ioQueue</code>是一个串行队列，这里新开线程，异步执行,不会阻塞UI</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="comment">// do not call the completion if cancelled</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 磁盘文件IO会增大内存消耗，放在自动释放池中，降低内存峰值</span></div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">            <span class="comment">// 通过key获取文件路径，然后通过文件路径获取data，其中文件路径内部是通过md5加密的</span></div><div class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">            </div><div class="line">            <span class="comment">// 内部实现也是先获取data，然后转换成Image，其中image是经过解压缩，根据屏幕同比例增大，甚至在必要情况下，解码重绘得到的，</span></div><div class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</div><div class="line">                <span class="comment">// 获取图片所占内存大小</span></div><div class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</div><div class="line">                <span class="comment">// 在磁盘中找到图片，先放入内存中，以便下次直接使用</span></div><div class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 查询结束返回更新UI</span></div><div class="line">            <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    <span class="comment">// 查询完成，返回缓存设置为SDImageCacheTypeDisk</span></div><div class="line">                    doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">   &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="缓存存储图片"><a href="#缓存存储图片" class="headerlink" title="缓存存储图片"></a>缓存存储图片</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)storeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</div><div class="line">         imageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData</div><div class="line">            forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key</div><div class="line">            toDisk:(<span class="built_in">BOOL</span>)toDisk</div><div class="line">        completion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock;</div></pre></td></tr></table></figure>
<ol>
<li><p>首先进行内存缓存，通过<code>NSCache</code>的<code>- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;</code>方法，</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 图片或者<span class="built_in">key</span>不存在的情况下，直接返回</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">image</span> || !<span class="built_in">key</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">            completionBlock();</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125;</div><div class="line">    // <span class="keyword">if</span> memory cache <span class="built_in">is</span> enabled</div><div class="line">    // 内存缓存</div><div class="line">    <span class="keyword">if</span> (self.config.shouldCacheImagesInMemory) &#123;</div><div class="line">        NSUInteger cost = SDCacheCostForImage(<span class="built_in">image</span>);</div><div class="line">        </div><div class="line">        [self.memCache setObject:<span class="built_in">image</span> forKey:<span class="built_in">key</span> cost:cost];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>磁盘缓存，通过<code>NSFileManager</code>把文件存储磁盘</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">if</span> (toDisk) &#123;</div><div class="line">        <span class="selector-tag">dispatch_async</span>(self.ioQueue, ^&#123;</div><div class="line">            NSData *data = imageData;</div><div class="line">            </div><div class="line">            <span class="selector-tag">if</span> (!data &amp;&amp; image) &#123;</div><div class="line">                <span class="comment">// 1. 根据data确定图片的格式，png/jpeg</span></div><div class="line">                SDImageFormat imageFormatFromData = <span class="selector-attr">[NSData sd_imageFormatForImageData:data]</span>;</div><div class="line">                <span class="comment">// 2. 格式不同，转换data的方式不同，</span></div><div class="line">                data = <span class="selector-attr">[image sd_imageDataAsFormat:imageFormatFromData]</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 3. 磁盘缓存，内部会做很多工作，是否io队列，创建文件夹，图片名字加密，是否存储iCloud，</span></div><div class="line">            [self <span class="attribute">storeImageDataToDisk</span>:data <span class="attribute">forKey</span>:key];</div><div class="line">            </div><div class="line">            <span class="comment">// 磁盘缓存需要时间，异步执行completionBlock，通知存储已经结束</span></div><div class="line">            if (completionBlock) &#123;</div><div class="line">                <span class="selector-tag">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    completionBlock();</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>回调<code>completeBlock</code>通知外部，存储已经完成</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">  completionBlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="缓存清除"><a href="#缓存清除" class="headerlink" title="缓存清除"></a>缓存清除</h3><p>通过上面已经知道，内存缓存是使用<code>NSCache</code>，磁盘缓存是使用<code>NSFileManager</code>，所以缓存清除，对应的内存清除<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.memCache removeObjectForKey:key]</div></pre></td></tr></table></figure></p>
<p>磁盘清除<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[_fileManager removeItemAtPath:[self defaultCachePathForKey:key] error:nil]</div></pre></td></tr></table></figure></p>
<h2 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h2><blockquote>
<p>Asynchronous downloader dedicated and optimized for image loading</p>
</blockquote>
<p>优化过的专门用于加载图片的异步下载器<br>核心方法是：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- <span class="params">(nullable SDWebImageDownloadToken *)</span>downloadImageWithURL:<span class="params">(nullable NSURL *)</span>url</div><div class="line">                                                   options:<span class="params">(SDWebImageDownloaderOptions)</span>options</div><div class="line">                                                  progress:<span class="params">(nullable SDWebImageDownloaderProgressBlock)</span>progressBlock</div><div class="line">                                                 completed:<span class="params">(nullable SDWebImageDownloaderCompletedBlock)</span>completedBlock;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>方法需要返回一个<code>SDWebImageDownloadToken</code>对象，它跟下载器一一对应，可以被用来取消对应的下载。它有两个属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURL</span> *url; <span class="comment">// 当前下载器对应的url地址</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span> downloadOperationCancelToken; <span class="comment">// 一个任意类型的对象，</span></div></pre></td></tr></table></figure>
</li>
<li><p>深入方法，内部实现其实是调用另一个方法。<br>该方法，用来添加各个回调方法block的。<br>而调用该一个方法，需要一个参数<code>SDWebImageDownloaderOperation</code>对象，block内部就是创建这个对象的。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> [self <span class="string">addProgressCallback:</span>progressBlock <span class="string">completedBlock:</span>completedBlock <span class="string">forURL:</span>url <span class="string">createCallback:</span>^SDWebImageDownloaderOperation *&#123; </div><div class="line">		<span class="comment">// 内部返回一个SDWebImageDownloaderOperation对象</span></div><div class="line">		<span class="comment">// 创建</span></div><div class="line">		SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] <span class="string">initWithRequest:</span>request <span class="string">inSession:</span>sself.session <span class="string">options:</span>options];</div><div class="line">		<span class="comment">// 返回</span></div><div class="line">		<span class="keyword">return</span> operation;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p><code>SDWebImageDownloaderOperation</code>继承于<code>NSOperation</code>，用来执行下载操作的。下面创建<code>SDWebImageDownloaderOperation</code>对象</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置请求时间限制</span></div><div class="line">  NSTimeInterval timeoutInterval = sself.downloadTimeout;</div><div class="line">  <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</div><div class="line">      timeoutInterval = <span class="number">15.0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span></div><div class="line">  <span class="comment">// 这里防止重复缓存，默认是阻止网络请求的缓存。</span></div><div class="line">  <span class="comment">// 创建网络请求request，并设置网络请求的缓存策略 ，是否使用网络缓存</span></div><div class="line">  NSMutableURLRequest *request = [[NSMutableURLRequest alloc] <span class="string">initWithURL:</span>url <span class="string">cachePolicy:</span>(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) <span class="string">timeoutInterval:</span>timeoutInterval];</div><div class="line">  <span class="comment">// 是否发送cookie</span></div><div class="line">  request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">  </div><div class="line">  <span class="comment">// 是否等待之前的返回响应，然后再发送请求</span></div><div class="line">  <span class="comment">// YES, 表示不等待</span></div><div class="line">  request.HTTPShouldUsePipelining = YES;</div><div class="line">  </div><div class="line">  <span class="comment">// 请求头</span></div><div class="line">  <span class="keyword">if</span> (sself.headersFilter) &#123;</div><div class="line">      request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders copy]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">      request.allHTTPHeaderFields = sself.HTTPHeaders;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 初始化一个图片下载操作，只有放入线程，或者调用start才会真正执行请求</span></div><div class="line">  <span class="comment">// 这里真正创建SDWebImageDownloaderOperation，</span></div><div class="line">  SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] <span class="string">initWithRequest:</span>request <span class="string">inSession:</span>sself.session <span class="string">options:</span>options];</div></pre></td></tr></table></figure>
</li>
<li><p>对下载操作<code>operation</code>的属性设置，并安排下载操作的优先级以及执行顺序</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 压缩图片</span></div><div class="line">   operation.shouldDecompressImages = sself.shouldDecompressImages;</div><div class="line">   </div><div class="line">   <span class="comment">// 对应网络请求设置请求凭证</span></div><div class="line">   <span class="keyword">if</span> (sself.urlCredential) &#123;</div><div class="line">       operation.credential = sself.urlCredential;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sself.username &amp;&amp; sself.password) &#123;</div><div class="line">       operation.credential = [NSURLCredential <span class="string">credentialWithUser:</span>sself.username <span class="string">password:</span>sself.password <span class="string">persistence:</span>NSURLCredentialPersistenceForSession];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="comment">// 操作执行的优先级</span></div><div class="line">   <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">       operation.queuePriority = NSOperationQueuePriorityHigh;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">       operation.queuePriority = NSOperationQueuePriorityLow;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 下载队列添加下载操作</span></div><div class="line">   [sself.downloadQueue <span class="string">addOperation:</span>operation];</div><div class="line">   </div><div class="line">   <span class="comment">// 根据执行顺序，添加依赖</span></div><div class="line">   <span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">       <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span></div><div class="line">       [sself.lastAddedOperation <span class="string">addDependency:</span>operation];</div><div class="line">       </div><div class="line">       sself.lastAddedOperation = operation;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>分析第2步中，添加各个回调block的方法。<br>这个方法最终操作，是返回 <code>SDWebImageDownloadToken</code>对象</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 所有的下载操作都是以一个真实的url为前提，一旦url为<span class="keyword">nil</span>，直接返回<span class="keyword">nil</span></div><div class="line">    <span class="keyword">if</span> (url == <span class="keyword">nil</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (completedBlock != <span class="keyword">nil</span>) &#123;</div><div class="line">            completedBlock(<span class="keyword">nil</span>, <span class="keyword">nil</span>, <span class="keyword">nil</span>, <span class="type">NO</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 方法最终是要返回<span class="type">SDWebImageDownloadToken</span>对象，这里声明，并使用__block修饰，以便在后续<span class="keyword">block</span>中进行修改赋值</div><div class="line">    __block <span class="type">SDWebImageDownloadToken</span> *token = <span class="keyword">nil</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>使用GCD中的栅栏，来保证字典写入操作不会发生冲突。其中涉及到一个属性<code>URLOperations</code>，类型为<code>NSMutableDictionary&lt;NSURL *, SDWebImageDownloaderOperation *&gt;</code>，用来存储url对应的下载操作。<br><strong>注意其中的a点，这里是把对应于同一个<code>url</code>的多个下载操作，合并为一个，就是说，如果有多张<code>ImageView</code>对应于一个<code>url</code>，实际上执行一个下载操作，但他们的进度和完成block还是分开处理的，后续才有数组<code>callbackBlocks</code>来存储所有的blocks，当下载完成后，所有的block执行回调。当然，<em>前提是操作未结束</em>，还没执行<code>completionBlock</code>。</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 多线程中的栅栏，barrierQueue 是一个并行队列</span></div><div class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">// a. 根据url判断是否有对应的operation</span></div><div class="line">        SDWebImageDownloaderOperation *operation = <span class="keyword">self</span>.URLOperations[url];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!operation) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">// 如果没有，就赋值，createCallback()就是之前第3步创建的SDWebImageDownloaderOperation对象</span></div><div class="line">            operation = createCallback();</div><div class="line">            </div><div class="line">            <span class="comment">// 对应于a操作，赋值，存储</span></div><div class="line">            <span class="keyword">self</span>.URLOperations[url] = operation;</div><div class="line"></div><div class="line">            __<span class="keyword">weak</span> SDWebImageDownloaderOperation *woperation = operation;</div><div class="line">            <span class="comment">// 设置完成之后的回调</span></div><div class="line">            operation.completionBlock = ^&#123;</div><div class="line">              </div><div class="line">                SDWebImageDownloaderOperation *soperation = woperation;</div><div class="line">              </div><div class="line">                <span class="keyword">if</span> (!soperation) <span class="keyword">return</span>;</div><div class="line">            </div><div class="line">                <span class="comment">// 操作已经结束了，移除该操作</span></div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.URLOperations[url] == soperation) &#123;</div><div class="line">                  </div><div class="line">                    [<span class="keyword">self</span>.URLOperations removeObjectForKey:url];</div><div class="line">              </div><div class="line">                &#125;</div><div class="line">            </div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 创建最终需要返回的对象，内部实现往下看</span></div><div class="line">        <span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</div><div class="line"></div><div class="line">        token = [SDWebImageDownloadToken new];</div><div class="line">        token.url = url;</div><div class="line">        token.downloadOperationCancelToken = downloadOperationCancelToken;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h2><blockquote>
<p><code>SDWebImageDownloaderOperation</code>继承于<code>NSOperation</code>，并实现了<code>&lt;SDWebImageDownloaderOperationInterface&gt;</code>协议，专门用来执行下载操作任务的。</p>
</blockquote>
<ol>
<li><p>对于上述第6点中的，添加存储下载进度的回调block和完成回调block。<br>涉及到一个隐藏属性<code>callbackBlocks</code>，类型为<code>NSMutableArray&lt;SDCallbacksDictionary *&gt;</code>，用来存储进度回调和完成回调的block<br>所有对应于url的执行任务的回调block，都存储其中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)addHandlersForProgress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                            completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">		 <span class="comment">// 可变字典 typedef NSMutableDictionary&lt;NSString *, id&gt; SDCallbacksDictionary;</span></div><div class="line">	    SDCallbacksDictionary *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">	    <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</div><div class="line">	    <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</div><div class="line">	    <span class="comment">// 使用栅栏，安全添加回调字典，</span></div><div class="line">	    dispatch_barrier_async(<span class="keyword">self</span>.barrierQueue, ^&#123;</div><div class="line">	        [<span class="keyword">self</span>.callbackBlocks addObject:callbacks];</div><div class="line">	    &#125;);</div><div class="line">	    <span class="keyword">return</span> callbacks;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>当<code>operation</code>添加进队列<code>downloadQueue</code>中后，会自动调用<code>start</code>方法，下面分析该方法<br>一旦操作取消，立马重置所有属性</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</div><div class="line">       <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</div><div class="line">       <span class="comment">// 内部会移除所有回调block，属性置空</span></div><div class="line">       [<span class="keyword">self</span> reset];</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>进入后台后继续执行网络请求任务。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if SD_UIKIT </span></div><div class="line">        Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</div><div class="line">        <span class="built_in">BOOL</span> hasApplication = <span class="built_in">UIApplicationClass</span> &amp;&amp; [<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">        <span class="comment">// 进入后台后也允许继续执行请求</span></div><div class="line">        <span class="keyword">if</span> (hasApplication &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) &#123;</div><div class="line">            __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</div><div class="line">            <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplicationClass</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">            <span class="comment">// 开启后台执行任务</span></div><div class="line">            <span class="keyword">self</span>.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line"></div><div class="line">                <span class="comment">// 后台执行是有时间限制的，当时间到期时，取消所有任务，关闭后台任务，并使之失效。</span></div><div class="line">                <span class="keyword">if</span> (sself) &#123;</div><div class="line">                    [sself cancel];</div><div class="line"></div><div class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</div><div class="line">                    sself.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
</li>
<li><p>创建数据请求任务</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// iOS 7 以后，使用NSURLSession 来进行网络请求</span></div><div class="line">   <span class="built_in">NSURLSession</span> *session = <span class="keyword">self</span>.unownedSession;</div><div class="line">   <span class="keyword">if</span> (!<span class="keyword">self</span>.unownedSession) &#123;</div><div class="line">       <span class="built_in">NSURLSessionConfiguration</span> *sessionConfig = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">       <span class="comment">// 请求时间</span></div><div class="line">       sessionConfig.timeoutIntervalForRequest = <span class="number">15</span>;</div><div class="line">       </div><div class="line">       <span class="comment">/**</span></div><div class="line">        *  Create the session for this task</div><div class="line">        *  We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate</div><div class="line">        *  method calls and completion handler calls.</div><div class="line">        */</div><div class="line">       <span class="comment">// 针对当前任务，创建session，</span></div><div class="line">       <span class="comment">// 这里代理队列为nil，所以，session创建一个串行操作队列，同步执行所有的代理方法和完成block回调</span></div><div class="line">       <span class="keyword">self</span>.ownedSession = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:sessionConfig</div><div class="line">                                                         delegate:<span class="keyword">self</span></div><div class="line">                                                    delegateQueue:<span class="literal">nil</span>];</div><div class="line">       session = <span class="keyword">self</span>.ownedSession;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="comment">// 创建数据请求任务</span></div><div class="line">   <span class="keyword">self</span>.dataTask = [session dataTaskWithRequest:<span class="keyword">self</span>.request];</div><div class="line">   <span class="keyword">self</span>.executing = <span class="literal">YES</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>任务开始执行<br>这里使用<code>@synchronized</code>，防止其他线程同时进行访问、处理。<br><code>self.dataTask</code>每次只能创建一个，不能同时创建多个</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@synchronized</span> (self) &#123; &#125;;</div><div class="line"><span class="comment">// 任务执行，请求发送</span></div><div class="line"><span class="selector-attr">[self.dataTask resume]</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>任务刚开始执行时候的处理</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.dataTask) &#123;</div><div class="line">        <span class="comment">// 任务刚开始执行，同一个url对应的所有progressBlocks，进行一次信息回调。</span></div><div class="line">        <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</div><div class="line">            progressBlock(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>, <span class="keyword">self</span>.request.URL);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 返回主线程发送通知，任务开始执行</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">// 如果任务不存在，回调错误信息，“请求链接不存在”</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Connection can't be initialized"</span>&#125;]];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>任务已经开始执行，后台任务就没必要存在了，关闭后台任务并使之失效</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if SD_UIKIT</span></div><div class="line">    Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</div><div class="line">    <span class="keyword">if</span>(!<span class="built_in">UIApplicationClass</span> || ![<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)]) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.backgroundTaskId != <span class="built_in">UIBackgroundTaskInvalid</span>) &#123;</div><div class="line">        <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">        [app endBackgroundTask:<span class="keyword">self</span>.backgroundTaskId];</div><div class="line">        <span class="keyword">self</span>.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
</li>
<li><p>数据请求，任务执行过程中，代理方法的各种回调<br> a. 任务已经获取完整的返回数据</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">URLSession</span><span class="selector-pseudo">:(NSURLSession</span> *)<span class="selector-tag">session</span></div><div class="line">          <span class="selector-tag">dataTask</span><span class="selector-pseudo">:(NSURLSessionDataTask</span> *)<span class="selector-tag">dataTask</span></div><div class="line"><span class="selector-tag">didReceiveResponse</span><span class="selector-pseudo">:(NSURLResponse</span> *)<span class="selector-tag">response</span></div><div class="line"> <span class="selector-tag">completionHandler</span><span class="selector-pseudo">:(void</span> (^)(NSURLSessionResponseDisposition disposition))<span class="selector-tag">completionHandler</span> &#123;</div><div class="line">	 	</div><div class="line">	 	<span class="comment">/*</span></div><div class="line">	 	 1. 进度回调一次，把图片完整大小传出去</div><div class="line">	 	 2. 发送通知，已经收到图片数据了</div><div class="line">	 	 3. 如果失败，取消任务，并重置，发送通知，以及回调错误信息</div><div class="line">	 	*/ </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> b. 网络数据接收过程中 </p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">URLSession</span><span class="selector-pseudo">:(NSURLSession</span> *)<span class="selector-tag">session</span> <span class="selector-tag">dataTask</span><span class="selector-pseudo">:(NSURLSessionDataTask</span> *)<span class="selector-tag">dataTask</span></div><div class="line">                                     <span class="selector-tag">didReceiveData</span><span class="selector-pseudo">:(NSData</span> *)<span class="selector-tag">data</span> &#123;</div><div class="line">	  </div><div class="line">	  <span class="comment">/*</span></div><div class="line">		1. data 拼接</div><div class="line">		2. 如果需要，图片一节一节的显示</div><div class="line">		3. 进度不断回调</div><div class="line">		*/</div><div class="line"></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> c. 主要用来进行网络数据缓存的处理</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">URLSession</span><span class="selector-pseudo">:(NSURLSession</span> *)<span class="selector-tag">session</span> <span class="selector-tag">task</span><span class="selector-pseudo">:(NSURLSessionTask</span> *)<span class="selector-tag">task</span></div><div class="line">                            <span class="selector-tag">didReceiveChallenge</span><span class="selector-pseudo">:(NSURLAuthenticationChallenge</span> *)<span class="selector-tag">challenge</span> </div><div class="line">                              <span class="selector-tag">completionHandler</span><span class="selector-pseudo">:(void</span> (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))<span class="selector-tag">completionHandler</span> &#123;</div><div class="line"> </div><div class="line">		 <span class="comment">/*</span></div><div class="line">		 	 进行非网络缓存的处理，或者进行特定的网络缓存处理</div><div class="line">		 */</div><div class="line"> </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> d. 刚接收完最后一条数据时调用的方法</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">URLSession</span><span class="selector-pseudo">:(NSURLSession</span> *)<span class="selector-tag">session</span> <span class="selector-tag">task</span><span class="selector-pseudo">:(NSURLSessionTask</span> *)<span class="selector-tag">task</span> <span class="selector-tag">didCompleteWithError</span><span class="selector-pseudo">:(NSError</span> *)<span class="selector-tag">error</span> &#123; </div><div class="line"></div><div class="line">		<span class="comment">/*</span></div><div class="line">		1. 发送通知，任务完成，停止任务</div><div class="line">		2. 图片处理并回调completionBlock</div><div class="line">		3. 任务完成</div><div class="line">		*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p><img src="http://oeb4c30x3.bkt.clouddn.com/SDWebImageDownload.jpeg" alt="SDWebImageDownloader &amp;&amp; SDWebImageDownloaderOperation"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong><em>1. <code>SDImageCache</code>主要是用来管理所有图片缓存相关方法的类，包括存储、获取、移除等</em></strong></p>
<p><strong><em>2. <code>SDWebImageDownloader</code>主要是用来处理生成<code>SDWebImageDownloaderOperation</code>的类，管理图片下载对应的操作，以及操作的一些属性设置。</em></strong></p>
<p><strong><em>3. <code>SDWebImageDownloaderOperation</code>用来管理数据网络请求的类，并把请求结果进行处理回调。</em></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图片加载之SDWebImage（上）]]></title>
      <url>http://lionwy.github.io/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B9%8BSDWebImage%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Asynchronous image downloader with cache support as a UIImageView category</p>
</blockquote>
<p>支持图片异步下载和缓存的UIImageView分类</p>
<p><img src="http://oeb4c30x3.bkt.clouddn.com/light.jpg" alt=""></p>
<h2 id="UIView-WebCache"><a href="#UIView-WebCache" class="headerlink" title="UIView+WebCache"></a>UIView+WebCache</h2><ol>
<li><p>最基本的方法是<code>UIImageView+WebCache</code>中这个方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</div></pre></td></tr></table></figure>
</li>
<li><p>一步步走下来，会发现实际运用的是<code>UIView+WebCache</code>中的方法，包括<code>UIButton+WebCache</code>内部核心方法也是调用的下面的方法，其中<code>SDWebImageOptions</code>策略详细介绍可以看<a href="https://github.com/LionWY/SourceCodeStorage/blob/master/Demo/SourceCode/SourceCode/libs/SDWebImage/SDWebImageManager.h" target="_blank" rel="external">这里</a></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                           options:(SDWebImageOptions)options</div><div class="line">                      operationKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)operationKey</div><div class="line">                     setImageBlock:(<span class="keyword">nullable</span> SDSetImageBlock)setImageBlock</div><div class="line">                          progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                         completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
</li>
<li><p>进入方法内部：先取消相关的所有下载</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  operationKey  用来描述当前操作的关键字标识，默认值是类名字，即 @"UIImageView"</span></div><div class="line"><span class="built_in">NSString</span> *validOperationKey = operationKey ?: <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</div><div class="line"></div><div class="line"><span class="comment">// 取消当前view下 跟validOperationKey有关的所有下载操作，以保证不会跟下面的操作有冲突</span></div><div class="line">[<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:validOperationKey];</div><div class="line"></div><div class="line"><span class="comment">// 通过runtime的关联对象给UIView添加属性，设置图片地址</span></div><div class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div></pre></td></tr></table></figure>
<p>其中取消操作方法内部涉及到一个协议<code>&lt;SDWebImageOperation&gt;</code>，这个协议只有一个<code>cancel</code>方法，可见，这个协议就是用来取消操作的，只要遵守该协议的类，必定会有<code>cancel</code>方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDWebImageOperation</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line">	- (<span class="keyword">void</span>)cancel;</div><div class="line"></div><div class="line">	<span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>取消方法的具体实现：<br>涉及到一个字典<code>SDOperationsDictionary</code>类型为<code>NSMutableDictionary&lt;NSString *, id&gt;</code>，也是通过关联对象添加为UIView的属性，用来存储UIView的所有下载操作，方便之后的取消/移除</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sd_cancelImageLoadOperationWithKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</div><div class="line">	    </div><div class="line">	    <span class="comment">// 从队列中取消跟key有关的所有下载操作</span></div><div class="line">	    <span class="comment">// 任何实现协议的对象都执行取消操作</span></div><div class="line">	    SDOperationsDictionary *operationDictionary = [<span class="keyword">self</span> operationDictionary];</div><div class="line">	    <span class="keyword">id</span> operations = operationDictionary[key];</div><div class="line">	    <span class="keyword">if</span> (operations) &#123;</div><div class="line">	        <span class="keyword">if</span> ([operations isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">		        </div><div class="line">	            <span class="keyword">for</span> (<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation <span class="keyword">in</span> operations) &#123;</div><div class="line">	                <span class="keyword">if</span> (operation) &#123;</div><div class="line">	                    [operation cancel];</div><div class="line">	                &#125;</div><div class="line">	            &#125;</div><div class="line">	        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([operations conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageOperation</span>)])</span>&#123;</div><div class="line">	            [(<span class="keyword">id</span>&lt;SDWebImageOperation&gt;) operations cancel];</div><div class="line">	        &#125;</div><div class="line">	        <span class="comment">// 最后从字典中移除key</span></div><div class="line">	        [operationDictionary removeObjectForKey:key];</div><div class="line">	    &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果没有设置延迟加载占位图<code>SDWebImageDelayPlaceholder</code>，就会先进行加载占位图，</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">	   <span class="selector-tag">dispatch_main_async_safe</span>(^&#123;</div><div class="line">     	       </div><div class="line">            <span class="comment">// 返回主线程中进行UI设置，把占位图当成image进行图片设置，在方法内部会进行UIButton和UIImageView的判断区分</span></div><div class="line">            <span class="selector-attr">[self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock]</span>;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其中有一个宏定义，通过字符串的比较来获取主线程</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#ifndef dispatch_main_async_safe</span></div><div class="line"><span class="comment">#define dispatch_main_async_safe(block)\</span></div><div class="line">	    <span class="keyword">if</span> (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == <span class="number">0</span>) &#123;<span class="string">\</span></div><div class="line">	        block();<span class="string">\</span></div><div class="line">	    &#125; <span class="keyword">else</span> &#123;<span class="string">\</span></div><div class="line">	        dispatch_async(dispatch_get_main_queue(), block);<span class="string">\</span></div><div class="line">	    &#125;</div><div class="line"><span class="comment">#endif</span></div></pre></td></tr></table></figure>
</li>
<li><p>判断url，url为空的情况下，直接返回错误信息</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (url) &#123;</div><div class="line">       <span class="comment">// check if activityView is enabled or not</span></div><div class="line">       <span class="comment">// 检查菊花</span></div><div class="line">       <span class="keyword">if</span> ([<span class="keyword">self</span> sd_showActivityIndicatorView]) &#123;</div><div class="line">           [<span class="keyword">self</span> sd_addActivityIndicator];</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// url 存在的情况下进行的操作...</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">// url 为nil的情况下，生成错误信息，并返回         </span></div><div class="line">       dispatch_main_async_safe(^&#123;</div><div class="line">           <span class="comment">// 移除菊花</span></div><div class="line">           [<span class="keyword">self</span> sd_removeActivityIndicator];</div><div class="line">           <span class="keyword">if</span> (completedBlock) &#123;</div><div class="line">               <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">-1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</div><div class="line">               completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>url不为nil的情况下，获取图片信息，并生成<code>operation</code>，然后存储。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回的是一个遵从了SDWebImageOperation协议的NSObject的子类，目的是方便之后的取消/移除操作</span></div><div class="line"><span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager loadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123; <span class="comment">/*完成之后的操作*/</span> &#125;];</div><div class="line">        </div><div class="line">	<span class="comment">// 根据validOperationKey把生成的operation放入字典`SDOperationsDictionary`中，这个字典也是通过关联对象，作为UIView的一个属性。</span></div><div class="line">	[<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:validOperationKey];</div></pre></td></tr></table></figure>
</li>
<li><p><code>SDInternalCompletionBlock</code>是在UIView内部使用的<code>completedBlock</code>，在block中，返回获取到的图片，以及相关信息。最后在主线程中，进行UI更新并更新布局。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// weak 避免 保留环</span></div><div class="line">   __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</div><div class="line">   </div><div class="line">   <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager loadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">       </div><div class="line">       <span class="comment">// block 中强引用替换，避免使用过程中被系统自动释放</span></div><div class="line">       __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line">       <span class="comment">// 加载完成移除菊花</span></div><div class="line">       [sself sd_removeActivityIndicator];</div><div class="line">       </div><div class="line">       <span class="keyword">if</span> (!sself) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       dispatch_main_async_safe(^&#123;</div><div class="line">           <span class="keyword">if</span> (!sself) &#123;</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// SDWebImageAvoidAutoSetImage, 对图片进行手动设置，开发者在外面的complete里面可以对图片设置特殊效果，然后赋值ImageView.image</span></div><div class="line">           <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) &#123;</div><div class="line">               completedBlock(image, error, cacheType, url);</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">               </div><div class="line">               <span class="comment">// 更新图片，内部会进行imageView或者button的判断</span></div><div class="line">               [sself sd_setImage:image imageData:data basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">               <span class="comment">// 更新布局Layout</span></div><div class="line">               [sself sd_setNeedsLayout];</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="comment">// SDWebImageDelayPlaceholder 延迟加载占位图，下载完成后才会进行设置</span></div><div class="line">               <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">                   [sself sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">                   [sself sd_setNeedsLayout];</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 如果有返回block，返回block和其它信息</span></div><div class="line">           <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</div><div class="line">               completedBlock(image, error, cacheType, url);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><img src="http://oeb4c30x3.bkt.clouddn.com/UIView+WebCache%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="UIView+WebCache流程图"></p>
<h2 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h2><blockquote>
<p>The SDWebImageManager is the class behind the UIImageView+WebCache category and likes. It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache). You can use this class directly to benefit from web image downloading with caching in another context than a UIView.</p>
</blockquote>
<p><code>SDWebImageManager</code>起一个承上启下的作用，紧密连接图片下载<code>SDWebImageDownloader</code>和图片缓存<code>SDImageCache</code>，可以直接通过这个类获取缓存中的图片。</p>
<p>核心方法（也是<code>UIView+WebCache</code>的第6步）：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;SDWebImageOperation&gt;)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                              options:(SDWebImageOptions)options</div><div class="line">                                             progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                            completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure></p>
<p>内部实现：</p>
<ol>
<li><p>如果<code>completedBlock</code>为空，直接闪退并抛出错误信息。即，<code>completedBlock</code>不能为空。</p>
<ul>
<li><p><code>NSAssert</code>只有在<code>debug</code>状态下有效</p>
<pre><code>// Invoking this method without a completedBlock is pointless
    NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);
</code></pre></li>
</ul>
</li>
<li><p>确保<code>url</code>是正确的，加安全验证，虽然<code>url</code>偶尔在字符串的情况下不报警告，但最好还是转换成<code>NSURL</code>类型，</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([url <span class="string">isKindOfClass:</span>NSString.<span class="keyword">class</span>]) &#123;</div><div class="line">        url = [NSURL <span class="string">URLWithString:</span>(NSString *)url];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 防止url在某些特殊情况下（eg：NSNull）导致app闪退</span></div><div class="line">    <span class="keyword">if</span> (![url <span class="string">isKindOfClass:</span>NSURL.<span class="keyword">class</span>]) &#123;</div><div class="line">        url = nil;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>首先方法要返回的是遵从了<code>&lt;SDWebImageOperation&gt;</code>协议的对象，所以声明了一个对象<code>SDWebImageCombinedOperation</code>，该对象遵从了协议，下面会对其属性进行一一设置。<br>而<code>cancelled</code>属性是在<code>UIView+WebCache</code>第3点设置的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isCancelled) <span class="built_in">BOOL</span> cancelled;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDWebImageNoParamsBlock cancelBlock;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSOperation</span> *cacheOperation;</div></pre></td></tr></table></figure>
<p>最后需要返回<code>operation</code>，所以进行创建、属性赋值、返回。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个SDWebImageCombinedOperation，加上 __block，可以让它在后续block内进行修改，</span></div><div class="line">    <span class="number">__</span>block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation <span class="keyword">new</span>];</div><div class="line">    <span class="comment">// 加上__weak 避免保留环</span></div><div class="line">    <span class="number">__</span><span class="keyword">weak</span> SDWebImageCombinedOperation *weakOperation = operation;</div><div class="line">    </div><div class="line">	<span class="comment">/*</span></div><div class="line">	对operation 进行赋值操作，最后返回</div><div class="line">	*/</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> operation;</div></pre></td></tr></table></figure>
</li>
<li><p>再次对<code>url</code>进行判断，<code>failedURLs</code>类型是<code>NSMutableSet&lt;NSURL *&gt;</code>，是用来存储错误<code>url</code>的集合</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明一个BOOL值，isFailedUrl</span></div><div class="line">  <span class="built_in">BOOL</span> isFailedUrl = <span class="literal">NO</span>;</div><div class="line">  <span class="keyword">if</span> (url) &#123;</div><div class="line">      <span class="comment">// 创建一个同步锁，@synchronized&#123;&#125;它防止不同的线程同时执行同一段代码</span></div><div class="line">      <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">          <span class="comment">// 错误的url都会放在failedURLs 中，判断该url是否在里面,返回并赋值isFailedUrl</span></div><div class="line">          isFailedUrl = [<span class="keyword">self</span>.failedURLs containsObject:url];</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 如果url长度为0，或者 options中没有 SDWebImageRetryFailed（一直进行下载）， 并且是错误的url</span></div><div class="line">  <span class="keyword">if</span> (url.absoluteString.length == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</div><div class="line">      </div><div class="line">      <span class="comment">// 不再向下执行，直接回调completeBlock，并传递错误信息，url不存在，NSURLErrorFileDoesNotExist</span></div><div class="line">      [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorFileDoesNotExist</span> userInfo:<span class="literal">nil</span>] url:url];</div><div class="line">      <span class="keyword">return</span> operation;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>runningOperations</code>类型为<code>NSMutableArray&lt;SDWebImageCombinedOperation *&gt;</code>存储所有待执行的操作任务</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@synchronized</span> (self.runningOperations) &#123;</div><div class="line">        <span class="comment">// 把operation 存储起来</span></div><div class="line">        <span class="selector-attr">[self.runningOperations addObject:operation]</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在缓存中查找图片，并将找到的图片的相关信息返回，<br>同时对<code>operation.cacheOperation</code>属性赋值。<br>（该方法是<code>SDImageCache</code>类的实例方法，下篇再分析）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据url 返回一个本地用来缓存的标志 key</span></div><div class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</div><div class="line">    </div><div class="line">    operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryCacheOperationForKey:key done:^(<span class="built_in">UIImage</span> *cachedImage, <span class="built_in">NSData</span> *cachedData, SDImageCacheType cacheType) &#123;	</div><div class="line">		 <span class="comment">// 查询结束后执行操作   </span></div><div class="line">     &#125;];</div></pre></td></tr></table></figure>
</li>
<li><p>缓存中是否查找到图片，分别处理：<br>a. 找不到图片，但是允许从网络下载，就进行网络下载</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果执行过程中操作取消，安全移除操作</span></div><div class="line"><span class="comment">// return 是跳出这个block</span></div><div class="line">   <span class="selector-tag">if</span> (operation.isCancelled) &#123;</div><div class="line">       <span class="selector-attr">[self safelyRemoveOperationFromRunning:operation]</span>;</div><div class="line">       return;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 1. 如果不存在缓存图片，或者需要刷新缓存 2. 代理可以响应方法，或者代理直接执行该方法，即从网络下载图片</span></div><div class="line">   <span class="comment">// 1 和 2 是并且关系</span></div><div class="line">   <span class="selector-tag">if</span> ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(<span class="attribute">imageManager</span>:<span class="attribute">shouldDownloadImageForURL</span>:)] || [self.delegate <span class="attribute">imageManager</span>:self <span class="attribute">shouldDownloadImageForURL</span>:url])) &#123; </div><div class="line">    		<span class="comment">//  网络下载图片</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>b. 如果找到了缓存图片，回调图片及相关信息，操作结束，安全移除操作</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cachedImage) &#123;</div><div class="line">       __strong __typeof(weakOperation) strongOperation = weakOperation;</div><div class="line">       [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>cachedImage <span class="string">data:</span>cachedData <span class="string">error:</span>nil <span class="string">cacheType:</span>cacheType <span class="string">finished:</span>YES <span class="string">url:</span>url];</div><div class="line">       [self <span class="string">safelyRemoveOperationFromRunning:</span>operation];</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>c. 缓存中找不到图片，也不允许网络下载图片：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">		  <span class="comment">// Image not in cache and download disallowed by delegate</span></div><div class="line">		  __strong __typeof(weakOperation) strongOperation = weakOperation;</div><div class="line">		  [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>nil <span class="string">data:</span>nil <span class="string">error:</span>nil <span class="string">cacheType:</span>SDImageCacheTypeNone <span class="string">finished:</span>YES <span class="string">url:</span>url];</div><div class="line">		  [self <span class="string">safelyRemoveOperationFromRunning:</span>operation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对a步骤一步步分析：如果有缓存图片，同时还要求刷新缓存，那么界面先加载缓存图片，然后网络下载，下载成功之后界面加载网络图片，然后在缓存中刷新之前的缓存图片</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">           </div><div class="line">		 <span class="comment">// If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span></div><div class="line">		 <span class="comment">// AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span></div><div class="line">		 <span class="comment">// 如果在缓存中找到了图片，但是设置了SDWebImageRefreshCached，因此要NSURLCache重新从服务器下载</span></div><div class="line">		 <span class="comment">// 先调用completeBlock后续进行网络下载</span></div><div class="line">		 [self <span class="string">callCompletionBlockForOperation:</span>weakOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>cachedImage <span class="string">data:</span>cachedData <span class="string">error:</span>nil <span class="string">cacheType:</span>cacheType <span class="string">finished:</span>YES <span class="string">url:</span>url];</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>根据<code>SDWebImageOptions</code>的选项对<code>SDWebImageDownloaderOptions</code>进行对接，一一对应，协调处理。<code>|=</code> 可以理解为<code>添加</code><br><code>SDWebImageDownloaderOptions</code>的详细介绍点<a href="https://github.com/LionWY/SourceCodeStorage/blob/master/Demo/SourceCode/SourceCode/libs/SDWebImage/SDWebImageDownloader.h" target="_blank" rel="external">这里</a></p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">downloaderOptions <span class="string">|= SDWebImageDownloaderLowPriority</span></div><div class="line"><span class="comment">// 等同于</span></div><div class="line">downloaderOptions = downloaderOptions <span class="string">| SDWebImageDownloaderLowPriority</span></div></pre></td></tr></table></figure>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// downloaderOptions 默认为0</span></div><div class="line"> SDWebImageDownloaderOptions downloaderOptions = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">options</span> &amp; SDWebImageLowPriority)  downloaderOptions |= SDWebImageDownloaderLowPriority;</div><div class="line">  </div><div class="line">    <span class="comment">// 如果需要刷新缓存，downloaderOptions强制解除SDWebImageDownloaderProgressiveDownload，并且添加SDWebImageDownloaderIgnoreCachedResponse选项</span></div><div class="line">  <span class="keyword">if</span> (cachedImage &amp;&amp; <span class="keyword">options</span> &amp; SDWebImageRefreshCached) &#123;</div><div class="line">	      <span class="comment">// force progressive off if image already cached but forced refreshing</span></div><div class="line">	      downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</div><div class="line">	      <span class="comment">// ignore image read from NSURLCache if image if cached but force refreshing</span></div><div class="line">	      downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过<code>url</code>进行网络下载图片：<br>每一个下载<code>SDWebImageDownloader</code>对象对应于一个<code>SDWebImageDownloadToken</code>对象，目的是用于取消/移除<code>SDWebImageDownloader</code>对象。<br>通过<code>SDWebImageDownloader</code>的实例方法生成一个<code>SDWebImageDownloadToken</code>对象。（该方法下篇分析）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SDWebImageDownloadToken *subOperationToken = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *downloadedData, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line"><span class="comment">// 图片下载完成之后的操作。</span></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>对<code>operation.cancelBlock</code>赋值。<br>通过上面生成的<code>subOperationToken</code>来进行取消<code>SDWebImageDownloader</code>操作</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">operation.cancelBlock</span> = ^&#123;</div><div class="line">	      [<span class="keyword">self.imageDownloader </span>cancel:<span class="keyword">subOperationToken];</span></div><div class="line">	      __strong __typeof(weakOperation) <span class="keyword">strongOperation </span>= weakOperation<span class="comment">;</span></div><div class="line">	      [<span class="keyword">self </span>safelyRemoveOperationFromRunning:<span class="keyword">strongOperation];</span></div><div class="line">  &#125;<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
<li><p>操作取消或者存在网络错误的情况下：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 操作不存在或者操作取消的情况下不做任何处理。</span></div><div class="line">__strong __typeof(weakOperation) strongOperation = weakOperation;</div><div class="line"><span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line">		<span class="comment">// https://github.com/rs/SDWebImage/pull/699</span></div><div class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">error</span>) &#123;</div><div class="line">	     [self callCompletionBlockForOperation:strongOperation completion:completedBlock <span class="built_in">error</span>:<span class="built_in">error</span> url:url];</div><div class="line">			<span class="comment">// 在下面情况下（不是因为网络问题），url本身有问题的情况下，才会添加进failedURLs</span></div><div class="line">	     <span class="keyword">if</span> (   <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorNotConnectedToInternet</div><div class="line">	         &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorCancelled</div><div class="line">	         &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorTimedOut</div><div class="line">	         &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorInternationalRoamingOff</div><div class="line">	         &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorDataNotAllowed</div><div class="line">	         &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorCannotFindHost</div><div class="line">	         &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorCannotConnectToHost) &#123;</div><div class="line">	         </div><div class="line">	         <span class="comment">// 跟前面第4点对应，failedURLs添加错误的url</span></div><div class="line">	         <span class="comment">@synchronized (self.failedURLs) &#123;</span></div><div class="line">	             [self.failedURLs addObject:url];</div><div class="line">	         &#125;</div><div class="line">	     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>成功情况下：<br>a. 对应于第8点，刷新缓存，并且图片下载失败的情况下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下载选项，允许失败后重新下载，</span></div><div class="line">     <span class="keyword">if</span> ((<span class="keyword">options</span> &amp; SDWebImageRetryFailed)) &#123;</div><div class="line">         <span class="comment">// 重新下载，得保证 url 是正确的，不在failedURLs里面</span></div><div class="line">         @<span class="keyword">synchronized</span> (self.failedURLs) &#123;</div><div class="line">             [self.failedURLs removeObject:url];</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">// 是否允许磁盘缓存</span></div><div class="line">     BOOL cacheOnDisk = !(<span class="keyword">options</span> &amp; SDWebImageCacheMemoryOnly);</div><div class="line"></div><div class="line">     <span class="comment">// 没有下载图片的情况下，不能刷新缓存</span></div><div class="line">     <span class="keyword">if</span> (<span class="keyword">options</span> &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</div><div class="line">         <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span></div><div class="line">         <span class="comment">// 对应于第8点，已经返回completeBlock，这里不做任何处理。</span></div><div class="line">         </div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>b. 1. 有下载图片 2. 界面上下载图片尚未赋值，或者策略允许图片变换 3. 代理响应了图片变换操作<br>1，2，3 是并且关系。<br>图片先进行变换，然后缓存，最后回调</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">else</span> <span class="selector-tag">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(<span class="attribute">imageManager</span>:<span class="attribute">transformDownloadedImage</span>:<span class="attribute">withURL</span>:)]) &#123;</div><div class="line">	    <span class="comment">// 在全局队列（并发）中，开启一个子线程，异步执行，优先级比较高</span></div><div class="line">	    <span class="selector-tag">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line">	        <span class="comment">// 在缓存之前，就对图片进行处理变换，外层要手动实现代理方法</span></div><div class="line">	        UIImage *transformedImage = <span class="selector-attr">[self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url]</span>;</div><div class="line">				<span class="comment">// 变换图片处理完成</span></div><div class="line">	        <span class="selector-tag">if</span> (transformedImage &amp;&amp; finished) &#123;</div><div class="line">	        		<span class="comment">// 判断图片是否变换</span></div><div class="line">	            BOOL imageWasTransformed = !<span class="selector-attr">[transformedImage isEqual:downloadedImage]</span>;</div><div class="line">	            <span class="comment">// pass nil if the image was transformed, so we can recalculate the data from the image</span></div><div class="line">	            <span class="comment">// 如果图片变换成功，imageData传nil，这样在缓存图片的时候，可以重新计算data大小，反之，就传downloadedData</span></div><div class="line">	            </div><div class="line">	            <span class="selector-attr">[self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil]</span>;</div><div class="line">	        &#125;</div><div class="line">	        <span class="comment">// 回调信息</span></div><div class="line">	        [self <span class="attribute">callCompletionBlockForOperation</span>:strongOperation <span class="attribute">completion</span>:completedBlock <span class="attribute">image</span>:transformedImage <span class="attribute">data</span>:downloadedData <span class="attribute">error</span>:nil <span class="attribute">cacheType</span>:SDImageCacheTypeNone <span class="attribute">finished</span>:finished <span class="attribute">url</span>:url];</div><div class="line">	    &#125;);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>c. 不对图片进行处理，直接缓存图片并回调。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">         <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">             [self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">imageData:</span>downloadedData <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk <span class="string">completion:</span>nil];</div><div class="line">         &#125;</div><div class="line">         [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>downloadedImage <span class="string">data:</span>downloadedData <span class="string">error:</span>nil <span class="string">cacheType:</span>SDImageCacheTypeNone <span class="string">finished:</span>finished <span class="string">url:</span>url];</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p><img src="http://oeb4c30x3.bkt.clouddn.com/SDWebImage%E6%B5%81%E7%A8%8B%E5%9B%BE.jpeg" alt="SDWebImageManager流程图"></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图片加载之AFNetwork（下）]]></title>
      <url>http://lionwy.github.io/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B9%8BAFNetwork%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="AFImageDownloader"><a href="#AFImageDownloader" class="headerlink" title="AFImageDownloader"></a>AFImageDownloader</h2><blockquote>
<p>The AFImageDownloader class is responsible for downloading images in parallel on a prioritized queue. Incoming downloads are added to the front or back of the queue depending on the download prioritization. Each downloaded image is cached in the underlying NSURLCache as well as the in-memory image cache. By default, any download request with a cached image equivalent in the image cache will automatically be served the cached image representation.</p>
</blockquote>
<p>AFImageDownloader类是负责下载图片的，并且根据下载优先级，把新传入的下载添加在队列的前面或后面。每个下载好的图片不仅被缓存在底层的NSURLCache中（NSURLCache只是被用来自动缓存网络请求，并没有进行图片缓存），也缓存在内存中的图片缓存中（上篇写的AFAutoPurgingImageCache类）。默认情况下，如果请求的图片有缓存的话，会直接返回缓存图片。</p>
<p><img src="http://oeb4c30x3.bkt.clouddn.com/research_2.jpg" alt="research_2.jpg"></p>
<p>1、简单了解下<code>AFImageDownloader</code>的主要属性</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.h 中可以被外部使用的属性</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span> &lt;AFImageRequestCache&gt; imageCache;<span class="comment">// 储存下载图片的对象</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFHTTPSessionManager *sessionManager;<span class="comment">// 进行数据请求的对象</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AFImageDownloadPrioritization downloadPrioritizaton;<span class="comment">// 下载优先级</span></div><div class="line">.m 中不让外部调用的属性有：</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> maximumActiveDownloads;<span class="comment">// 同时处理线程的最大值，默认为4</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> activeRequestCount;<span class="comment">// 正在进行的请求数量，</span></div></pre></td></tr></table></figure>
<p>2、<code>AFImageDownloader</code> 有两个属性<code>queuedMergedTasks</code>，<code>mergedTasks</code>用来存储另一个对象<code>AFImageDownloaderMergedTask</code>（用来操作下载任务合并的对象）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *URLIdentifier;<span class="comment">// 数据请求的URL地址</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *identifier;<span class="comment">// 下载任务的唯一标识</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionDataTask</span> *task; <span class="comment">// 处理数据请求任务的对象</span></div></pre></td></tr></table></figure>
<p>3、<code>AFImageDownloaderMergedTask</code>有一个属性<code>responseHandlers</code>来存储返回结果操作的对象<code>AFImageDownloaderResponseHandler</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *uuid;<span class="comment">// 合并任务的唯一标识</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^successBlock)(<span class="built_in">NSURLRequest</span>*, <span class="built_in">NSHTTPURLResponse</span>*, <span class="built_in">UIImage</span>*);<span class="comment">// 成功块</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^failureBlock)(<span class="built_in">NSURLRequest</span>*, <span class="built_in">NSHTTPURLResponse</span>*, <span class="built_in">NSError</span>*);<span class="comment">// 失败块</span></div></pre></td></tr></table></figure>
<p>4、返回到昨天那个处理图片下载的核心方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> AFImageDownloadReceipt *)downloadImageForURLRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                                                 withReceiptID:(<span class="built_in">NSUUID</span> *)receiptID</div><div class="line">                                                        success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span>  * _Nullable response, <span class="built_in">UIImage</span> *responseObject))success</div><div class="line">                                                        failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure;</div></pre></td></tr></table></figure>
<p>返回值是<code>AFImageDownloadReceipt</code>，而它的声明方法只有一个，因此需要一个NSURLSessionDataTask对象（iOS 7.0 以后，代替<code>NSURLConnection</code>用来处理数据请求的类）<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@implementation <span class="type">AFImageDownloadReceipt</span></div><div class="line">- (instance<span class="keyword">type</span>)initWithReceiptID:(<span class="type">NSUUID</span> *)receiptID task:(<span class="type">NSURLSessionDataTask</span> *)task</div></pre></td></tr></table></figure></p>
<p>5、声明一个NSURLSessionDataTask对象，用来创建<code>AFImageDownloadReceipt</code>。<code>__block</code>修饰，用来在block中更改task值，</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__block <span class="built_in">NSURLSessionDataTask</span> *task = <span class="literal">nil</span>;</div></pre></td></tr></table></figure>
<p>6、在一个串行队列里中同步执行，直至结束，如果task存在，创建<code>AFImageDownloadReceipt</code>并返回，否则返回nil</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_sync(self.synchronizationQueue, ^&#123; </div><div class="line">	// 在block中对<span class="keyword">task</span>进行赋值</div><div class="line">&#125;;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">task</span>) &#123;</div><div class="line">        <span class="keyword">return</span> [[AFImageDownloadReceipt alloc] initWithReceiptID:receiptID <span class="keyword">task</span>:<span class="keyword">task</span>];</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">   <span class="keyword">return</span> nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>7、再次对URLRequest进行判断</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *URLIdentifier = request.URL.absoluteString;</div><div class="line"><span class="comment">// 如果请求地址有误，直接就进行失败回调</span></div><div class="line"><span class="keyword">if</span> (URLIdentifier == <span class="literal">nil</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (failure) &#123;</div><div class="line">      <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorBadURL</span> userInfo:<span class="literal">nil</span>];</div><div class="line">      <span class="comment">// 因为会有UI的交互，所以返回主线程处理failure</span></div><div class="line">      <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">          failure(request, <span class="literal">nil</span>, error);</div><div class="line">      &#125;);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// return 是跳出这个同步线程</span></div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>8、如果请求已经存在，并且根据url地址能够找到AFImageDownloaderMergedTask，直接返回对应的task，然后外层赋值。</p>
<ul>
<li><p>这里可以看出来<code>AFImageDownloaderMergedTask</code>类的作用：</p>
<ol>
<li>当请求地址是同一个的时候，并且第一个请求正在进行中，后续就不再向服务器发送请求。这也是AFNetwork比较优化的一点，主要用来多张不同的imageView同时请求一个URL地址的情况。跟上篇那个同一张图片多次请求一个URL地址的情况比较一下（第6点）。</li>
<li>不同请求对应的成功失败块也没有统一处理，根据下载任务对应的唯一标识<code>receiptID</code>和成功失败块，生成<code>AFImageDownloaderResponseHandler</code>，来进行分别处理。</li>
<li>而合并任务的task就是外层需要的task，即创建<code>AFImageDownloadReceipt</code>的task</li>
</ol>
</li>
<li><p>如果是首次请求，后面肯定会有对应的赋值操作，往下看</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">AFImageDownloaderMergedTask *existingMergedTask = self.mergedTasks[URLIdentifier];</div><div class="line">        </div><div class="line">   <span class="keyword">if</span> (existingMergedTask != nil) &#123;</div><div class="line">       <span class="comment">// AFImageDownloaderResponseHandler 用来处理返回结果的类</span></div><div class="line">       </div><div class="line">       AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] <span class="string">initWithUUID:</span>receiptID <span class="string">success:</span>success <span class="string">failure:</span>failure];</div><div class="line">       [existingMergedTask <span class="string">addResponseHandler:</span>handler];</div><div class="line">       task = existingMergedTask.task;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>9、 根据缓存策略在缓存中是否进行第二次的查找</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (request.cachePolicy) &#123;</div><div class="line">  <span class="comment">// 对特定的 URL 请求使用网络协议中实现的缓存逻辑。这是默认的策略</span></div><div class="line">  <span class="keyword">case</span> <span class="built_in">NSURLRequestUseProtocolCachePolicy</span>:</div><div class="line">  <span class="comment">// 无论缓存是否过期，先使用本地缓存数据。如果缓存中没有请求所对应的数据，那么从原始地址加载数据</span></div><div class="line">  <span class="keyword">case</span> <span class="built_in">NSURLRequestReturnCacheDataElseLoad</span>:</div><div class="line">  <span class="comment">// 无论缓存是否过期，先使用本地缓存数据。如果缓存中没有请求所对应的数据，那么放弃从原始地址加载数据，请求视为失败（即：“离线”模式）</span></div><div class="line">  <span class="keyword">case</span> <span class="built_in">NSURLRequestReturnCacheDataDontLoad</span>: &#123;</div><div class="line">      <span class="built_in">UIImage</span> *cachedImage = [<span class="keyword">self</span>.imageCache imageforRequest:request withAdditionalIdentifier:<span class="literal">nil</span>];</div><div class="line">      <span class="keyword">if</span> (cachedImage != <span class="literal">nil</span>) &#123;</div><div class="line">          <span class="keyword">if</span> (success) &#123;</div><div class="line">              <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                  success(request, <span class="literal">nil</span>, cachedImage);</div><div class="line">              &#125;);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>10、创建网络下载任务，进行图片下载，并处理返回结果<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 合并任务的唯一标识，</span></div><div class="line"><span class="built_in">NSUUID</span> *mergedTaskIdentifier = [<span class="built_in">NSUUID</span> UUID];</div><div class="line"><span class="comment">// 声明一个数据请求任务</span></div><div class="line"><span class="built_in">NSURLSessionDataTask</span> *createdTask;</div><div class="line">__<span class="keyword">weak</span> __typeof__(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line"><span class="comment">// 返回数据请求任务</span></div><div class="line">createdTask = [<span class="keyword">self</span>.sessionManager</div><div class="line">             dataTaskWithRequest:request</div><div class="line">             uploadProgress:<span class="literal">nil</span></div><div class="line">             downloadProgress:<span class="literal">nil</span></div><div class="line">             completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123; </div><div class="line">             <span class="comment">// 数据下载完成后的处理</span></div><div class="line">             &#125;];</div></pre></td></tr></table></figure></p>
<p>11、对应第8点中的取值操作，这里进行赋值操作。注意一个关键字<code>mergedTaskIdentifier</code>，是合并任务的唯一标识</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] <span class="string">initWithUUID:</span>receiptID <span class="string">success:</span>success <span class="string">failure:</span>failure];</div><div class="line">        </div><div class="line">AFImageDownloaderMergedTask *mergedTask = [[AFImageDownloaderMergedTask alloc] <span class="string">initWithURLIdentifier:</span>URLIdentifier <span class="string">identifier:</span>mergedTaskIdentifier <span class="string">task:</span>createdTask];</div><div class="line">   </div><div class="line">[mergedTask <span class="string">addResponseHandler:</span>handler];</div><div class="line">self.mergedTasks[URLIdentifier] = mergedTask;</div></pre></td></tr></table></figure>
<p>12、当前任务创建已经完成，根据线程中正在进行的请求数量来决定，是进行下一个任务，还是等待。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> isActiveRequestCountBelowMaximumLimit]) &#123;</div><div class="line">  [<span class="keyword">self</span> startMergedTask:mergedTask];</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  [<span class="keyword">self</span> enqueueMergedTask:mergedTask];</div><div class="line">&#125;</div><div class="line"><span class="comment">// 最后数据请求任务赋值</span></div><div class="line">task = mergedTask.task;</div></pre></td></tr></table></figure>
<p>13、下面线深入12中的方法，最后再啃硬骨头10中的方法<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 正在进行的请求是否已经达到最大值（之前默认为4）</span></div><div class="line">- (BOOL)isActiveRequestCountBelowMaximumLimit &#123;</div><div class="line">    <span class="keyword">return</span> self.activeRequestCount &lt; self.maximumActiveDownloads;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果没有，任务就开始发起请求，并且更新当前请求数量的值</span></div><div class="line">- (<span class="keyword">void</span>)<span class="string">startMergedTask:</span>(AFImageDownloaderMergedTask *)mergedTask &#123;</div><div class="line">    [mergedTask.task resume];</div><div class="line">    ++self.activeRequestCount;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 暂时挂起数据任务，然后按顺序放入数组中，直到有空余的线程来处理数据请求任务</span></div><div class="line">- (<span class="keyword">void</span>)<span class="string">enqueueMergedTask:</span>(AFImageDownloaderMergedTask *)mergedTask &#123;</div><div class="line">    <span class="keyword">switch</span> (self.downloadPrioritizaton) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">AFImageDownloadPrioritizationFIFO:</span><span class="comment">// 先进先出，放入数组后面</span></div><div class="line">            [self.queuedMergedTasks <span class="string">addObject:</span>mergedTask];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">AFImageDownloadPrioritizationLIFO:</span><span class="comment">// 后进先出，放入数组的第一个，优先处理</span></div><div class="line">            [self.queuedMergedTasks <span class="string">insertObject:</span>mergedTask <span class="string">atIndex:</span><span class="number">0</span>];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>14、最后来处理当图片下载任务（即网络请求任务）已经完成，之后的操作</p>
<ol>
<li><p>首先请求结果的处理都是在异步线程中执行的，避免线程阻塞，一直在等待网络请求完成 </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">dispatch_async</span>(<span class="selector-tag">self</span><span class="selector-class">.responseQueue</span>, ^&#123; &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>针对第8点，第11点，所有针对返回结果的操作都是跟<code>AFImageDownloaderMergedTask</code>绑定的，所以找到对应于url地址的合并任务，并且根据合并任务的唯一标识判断是否同一个，</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AFImageDownloaderMergedTask *mergedTask = self.mergedTasks<span class="string">[URLIdentifier]</span>;</div><div class="line">                               </div><div class="line">	if (<span class="string">[mergedTask.identifier isEqual:mergedTaskIdentifier]</span>) &#123;</div><div class="line">	</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>跟之前从字典获取的其实是同一个合并任务，这句话主要用来任务完成了，在字典中移除键值对</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">mergedTask</span> = [strongSelf safelyRemoveMergedTaskWithURLIdentifier:URLIdentifier];</div></pre></td></tr></table></figure>
</li>
<li><p>遍历同一个url对应的所有的失败块，都失败了，回调失败信息</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 失败处理</span></div><div class="line"><span class="selector-tag">if</span> (error) &#123;</div><div class="line"></div><div class="line">	    <span class="selector-tag">for</span> (AFImageDownloaderResponseHandler *handler in mergedTask.responseHandlers) &#123;</div><div class="line">	        <span class="selector-tag">if</span> (handler.failureBlock) &#123;</div><div class="line">	            <span class="selector-tag">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">	                handler<span class="selector-class">.failureBlock</span>(request, (NSHTTPURLResponse*)response, error);</div><div class="line">	            &#125;);</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>成功情况下，先进行图片缓存，再对所有的成功块，进行成功信息回调</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[<span class="name">strongSelf.imageCache</span> addImage:responseObject forRequest:request withAdditionalIdentifier:nil]<span class="comment">;</span></div><div class="line"></div><div class="line">	for (<span class="name">AFImageDownloaderResponseHandler</span> *handler in mergedTask.responseHandlers) &#123;</div><div class="line">	   // 成功回调处理</div><div class="line">	   if (<span class="name">handler.successBlock</span>) &#123;</div><div class="line">	       dispatch_async(<span class="name">dispatch_get_main_queue</span>(), ^&#123;</div><div class="line">	           handler.successBlock(<span class="name">request</span>, (<span class="name">NSHTTPURLResponse*</span>)response, responseObject)<span class="comment">;</span></div><div class="line">	       &#125;)<span class="comment">;</span></div><div class="line">	   &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最后，请求结束了，当前执行的请求数量-1，</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)safelyDecrementActiveTaskCount &#123;</div><div class="line">	    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</div><div class="line">	        <span class="keyword">if</span> (<span class="keyword">self</span>.activeRequestCount &gt; <span class="number">0</span>) &#123;</div><div class="line">	            <span class="keyword">self</span>.activeRequestCount -= <span class="number">1</span>;</div><div class="line">	        &#125;</div><div class="line">	    &#125;);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果还有需要执行的线程，就启动下一个线程</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">safelyStartNextTaskIfNecessary</span> &#123;</div><div class="line">	    <span class="selector-tag">dispatch_sync</span>(self.synchronizationQueue, ^&#123;</div><div class="line">	        <span class="selector-tag">if</span> ([self isActiveRequestCountBelowMaximumLimit]) &#123;</div><div class="line">	            <span class="selector-tag">while</span> (self.queuedMergedTasks.count &gt; <span class="number">0</span>) &#123;</div><div class="line">	                AFImageDownloaderMergedTask *mergedTask = <span class="selector-attr">[self dequeueMergedTask]</span>;</div><div class="line">	                <span class="selector-tag">if</span> (mergedTask.task.state == NSURLSessionTaskStateSuspended) &#123;</div><div class="line">	                    <span class="selector-attr">[self startMergedTask:mergedTask]</span>;</div><div class="line">	                    break;</div><div class="line">	                &#125;</div><div class="line">	            &#125;</div><div class="line">	        &#125;</div><div class="line">	    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>目前这就是AFNetwork中加载图片的所有流程，当然数据请求还没有涉及，想研究这个入口的时候再进行深入<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                    parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                      progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> * _Nonnull))uploadProgress</div><div class="line">                       success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull, <span class="keyword">id</span> _Nullable))success</div><div class="line">                       failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable, <span class="built_in">NSError</span> * _Nonnull))failure</div></pre></td></tr></table></figure></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong><em>1. AFNetwork把加载图片的任务都放入一个字典中，然后把任务对应的网络请求放入数组中，然后按顺序执行</em></strong></p>
<p><strong><em>2. 在图片加载过程中，除了在针对请求结果处理的时候是异步进行的，其他全是同步进行的</em></strong></p>
<p><strong><em>3. 一家之言，请多指教</em></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图片加载之AFNetwork（上）]]></title>
      <url>http://lionwy.github.io/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B9%8BAFNetwork%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="UIImageView-AFNetworking"><a href="#UIImageView-AFNetworking" class="headerlink" title="UIImageView+AFNetworking"></a>UIImageView+AFNetworking</h2><blockquote>
<p>This category adds methods to the UIKit framework’s UIImageView class. The methods in this category provide support for loading remote images asynchronously from a URL.</p>
</blockquote>
<p>给UIImageView添加分类方法，通过一个URL异步加载远程图片</p>
<p><img src="http://oeb4c30x3.bkt.clouddn.com/research.jpg" alt="research.jpg"></p>
<ol>
<li><p>核心方法就是下面很简单的方法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- <span class="params">(void)</span>setImageWithURL:<span class="params">(NSURL *)</span>url;</div></pre></td></tr></table></figure>
</li>
<li><p>内部实现，创建图片请求，并在请求头添加参数,后续的所有操作都是跟request有关</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)<span class="string">setImageWithURL:</span>(NSURL *)url</div><div class="line"><span class="symbol">       placeholderImage:</span>(UIImage *)placeholderImage</div><div class="line">&#123;</div><div class="line">	    NSMutableURLRequest *request = [NSMutableURLRequest <span class="string">requestWithURL:</span>url];</div><div class="line">	    [request <span class="string">addValue:</span>@<span class="string">"image/*"</span> <span class="string">forHTTPHeaderField:</span>@<span class="string">"Accept"</span>];</div><div class="line">	</div><div class="line">	    [self <span class="string">setImageWithURLRequest:</span>request <span class="string">placeholderImage:</span>placeholderImage <span class="string">success:</span>nil <span class="string">failure:</span>nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上面两个方法最终调用的都是下面的方法，下面就针对最核心的方法，一步步分析它的具体实现</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setImageWithURLRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest</div><div class="line">              placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholderImage</div><div class="line">                       success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> *image))success</div><div class="line">                       failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure;</div></pre></td></tr></table></figure>
</li>
<li><p>在任何请求发生之前，都要进行URLRequest的判断。如果URL为空，就取消图片下载任务，并直接设置占位图</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([urlRequest URL] == <span class="literal">nil</span>) &#123;</div><div class="line">    </div><div class="line">    <span class="regexp">//</span> 对于当前的这个任务，取消所有正在执行的图片下载操作，并把下载回执置空</div><div class="line">    [<span class="keyword">self</span> cancelImageDownloadTask];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.image = placeholderImage;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上面方法里面涉及到两个类<code>AFImageDownloadReceipt</code> <code>AFImageDownloader</code></p>
<ul>
<li><p>首先需要明白一个规则：图片下载任务的取消不是由任务自己取消，而是通过“下载回执”取消</p>
</li>
<li><p>AFImageDownloader：用来处理图片下载的类，所有下载任务都由它处理</p>
</li>
<li><p>AFImageDownloadReceipt：“下载回执”，跟AFImageDownloader一一对应，主要是用来取消AFImageDownloader正在运行的任务，只有两个属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionDataTask</span> *task;<span class="comment">// 下载任务，即AFImageDownloader执行的任务</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *receiptID;<span class="comment">//任务的唯一标识，用来区分两个任务是否相同</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>根据<code>URLRequest</code>来判断两次请求是否同一个，即，阻止同一张图片进行多次相同的请求，优化请求。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> <span class="symbol">isActiveTaskURLEqualToURLRequest:</span>urlRequest])&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>AFImageRequestCache</code>协议，是用来添加、删除、访问图片。这里把下载器存储图片的对象赋值给一个支持该协议的对象，用来获取缓存图片</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id &lt;AFImageRequestCache&gt; imageCache = downloader.imageCache<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
<li><p>通过URLrequest在缓存中查找图片，如果能找到，就返回缓存图片，操作结束。缓存见<a href="https://lionwy.github.io/%E5%9B%BE%E7%89%87%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E4%B9%8BAFNetwork%EF%BC%88%E4%B8%80%EF%BC%89/#AFAutoPurgingImageCache">这里</a></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIImage</span> *cachedImage = [imageCache imageforRequest:urlRequest withAdditionalIdentifier:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">if</span> (cachedImage) &#123;</div><div class="line">        <span class="comment">// 如果需要返回结果，就进行回调，在回调block中进行手动设置imageView.image</span></div><div class="line">        <span class="keyword">if</span> (success) &#123;</div><div class="line">            success(urlRequest, <span class="literal">nil</span>, cachedImage);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">self</span>.image = cachedImage;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 操作已经完成，把下载回执置空，</span></div><div class="line">        [<span class="keyword">self</span> clearActiveDownloadInformation];</div><div class="line">     </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果有占位图，就先设置占位图。<code>NSUUID</code>是用来创建唯一标识的，每次调用<code>UUID</code>返回结果都不一样，对应于下载回执的任务标识<code>receiptID</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (placeholderImage) &#123;</div><div class="line">  		<span class="keyword">self</span>.image = placeholderImage;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 弱引用，防止保留环</span></div><div class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</div><div class="line"><span class="built_in">NSUUID</span> *downloadID = [<span class="built_in">NSUUID</span> UUID];</div></pre></td></tr></table></figure>
</li>
<li><p>根据<code>URLrequest</code>和<code>receiptID</code>进行图片下载，返回的是对应下载操作的回执<code>AFImageDownloadReceipt</code>，具体实现下一篇马上呈现</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> AFImageDownloadReceipt *)downloadImageForURLRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                                                 withReceiptID:(<span class="built_in">NSUUID</span> *)receiptID</div><div class="line">                                                        success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span>  * _Nullable response, <span class="built_in">UIImage</span> *responseObject))success</div><div class="line">                                                        failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure;</div></pre></td></tr></table></figure>
</li>
<li><p>获取图片成功的情况下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 首先在<span class="keyword">block中，强引用下，避免在运行过程中，self被自动释放</span></div><div class="line">   __strong __typeof(weakSelf)<span class="keyword">strongSelf </span>= weakSelf<span class="comment">;</span></div><div class="line">   // 根据任务标识判断，避免返回结果对应的请求不是之前的那个请求</div><div class="line">   <span class="meta">if</span> ([<span class="keyword">strongSelf.af_activeImageDownloadReceipt.receiptID </span>isEqual:downloadID]) &#123;</div><div class="line">   	   // 如果有成功块，就返回成功块，并在<span class="keyword">block中手动设置图片</span></div><div class="line">       <span class="meta">if</span> (success) &#123;</div><div class="line">           success(request, response, responseObject)<span class="comment">;</span></div><div class="line">       &#125; <span class="meta">else</span> <span class="meta">if</span>(responseObject) &#123;</div><div class="line">           <span class="keyword">strongSelf.image </span>= responseObject<span class="comment">;</span></div><div class="line">       &#125;</div><div class="line">       // 操作完成，下载回执置空</div><div class="line">       [<span class="keyword">strongSelf </span>clearActiveDownloadInformation]<span class="comment">;</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>失败情况下，返回错误信息，并清空下载信息</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class="line"><span class="keyword">if</span> ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) &#123;</div><div class="line">   <span class="keyword">if</span> (failure) &#123;</div><div class="line">       failure(<span class="built_in">request</span>, <span class="built_in">response</span>, <span class="keyword">error</span>);</div><div class="line">   &#125;</div><div class="line">   [strongSelf clearActiveDownloadInformation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>把返回的下载回执，赋值给图片对应的下载回执，对应最开始的第6点，也就是说，当一张图片正在进行下载操作，如果再进行一次相同的请求，那么第二次请求直接返回，继续执行第一次的请求，直到请求结束，然后赋值。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.af_activeImageDownloadReceipt = receipt<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="AFAutoPurgingImageCache"><a href="#AFAutoPurgingImageCache" class="headerlink" title="AFAutoPurgingImageCache"></a>AFAutoPurgingImageCache</h2><blockquote>
<p>The AutoPurgingImageCache in an in-memory image cache used to store images up to a given memory capacity. When the memory capacity is reached, the image cache is sorted by last access date, then the oldest image is continuously purged until the preferred memory usage after purge is met. Each time an image is accessed through the cache, the internal access date of the image is updated.</p>
</blockquote>
<p>这个类是用来在内存中进行图片缓存操作的，并且会根据图片使用时间排序，当内存快满的时候，先释放最久未使用的图片，然后再清除优先使用内存里面的图片。每次使用图片后，图片使用时间都会更新。<br>这个类遵循<code>AFImageRequestCache</code>协议，因此可以使用协议方法</p>
<ol>
<li><p>内存分类：默认内存100M，优先使用内存60M。并且使用<code>cachedImages</code>来存储所有的图片对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> memoryCapacity;<span class="comment">//总内存</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> preferredMemoryUsageAfterPurge;<span class="comment">//优先使用内存</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">UInt64</span> memoryUsage;<span class="comment">//内存已使用容量</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> &lt;<span class="built_in">NSString</span>* , AFCachedImage*&gt; *cachedImages;<span class="comment">//可变字典来存储图片对象</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> currentMemoryUsage;<span class="comment">//当前内存使用情况，跟memoryUsage一样的</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> synchronizationQueue;<span class="comment">//同步线程</span></div></pre></td></tr></table></figure>
</li>
<li><p>这里涉及到一个类<code>AFCachedImage</code>，用来存储图片以及图片信息的类</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *image;<span class="comment">//图片</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *identifier;<span class="comment">//图片标识</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> totalBytes;<span class="comment">//图片大小</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *lastAccessDate;<span class="comment">//最新使用日期</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> currentMemoryUsage;<span class="comment">//当前内存已使用容量</span></div></pre></td></tr></table></figure>
</li>
<li><p>这里有个方法可以学习下，如何计算图片所占内存</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据屏幕进行等比例的缩减/扩大图片size</span></div><div class="line">CGSize imageSize = CGSizeMake(<span class="built_in">image</span>.<span class="built_in">size</span>.<span class="built_in">width</span> * <span class="built_in">image</span>.<span class="built_in">scale</span>, <span class="built_in">image</span>.<span class="built_in">size</span>.<span class="built_in">height</span> * <span class="built_in">image</span>.<span class="built_in">scale</span>);</div><div class="line">CGFloat bytesPerPixel = <span class="number">4.0</span>;</div><div class="line">CGFloat bytesPerSize = imageSize.<span class="built_in">width</span> * imageSize.<span class="built_in">height</span>;</div><div class="line">self.totalBytes = (UInt64)bytesPerPixel * (UInt64)bytesPerSize;</div></pre></td></tr></table></figure>
</li>
<li><p>回到上面那个协议方法，返回一个对应于<code>request</code>和<code>identifier</code>的图片</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageforRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)identifier;</div></pre></td></tr></table></figure>
</li>
<li><p>图片的Identifier，直接拼接url和additionalIdentifier</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)imageCacheKeyFromURLRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)additionalIdentifier &#123;</div><div class="line">	    <span class="built_in">NSString</span> *key = request.URL.absoluteString;</div><div class="line">	    <span class="keyword">if</span> (additionalIdentifier != <span class="literal">nil</span>)</div><div class="line">	    &#123;</div><div class="line">	        key = [key stringByAppendingString:additionalIdentifier];</div><div class="line">	    &#125;</div><div class="line">	    <span class="keyword">return</span> key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>根据图片的Identifier，在可变字典中获取需要的图片，并更新使用时间。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageWithIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</div><div class="line">	    __block <span class="built_in">UIImage</span> *image = <span class="literal">nil</span>;</div><div class="line">	    <span class="comment">// 同步操作，获取缓存图片</span></div><div class="line">	    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</div><div class="line">	        <span class="comment">// 用来存储图片信息的类</span></div><div class="line">	        AFCachedImage *cachedImage = <span class="keyword">self</span>.cachedImages[identifier];</div><div class="line">	        image = [cachedImage accessImage];</div><div class="line">	    &#125;);</div><div class="line">	    </div><div class="line">	    <span class="keyword">return</span> image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>内存中添加图片，使用栅栏保证线程安全，栅栏即，把之前所有的事情处理完毕之后，再进行栅栏中的处理，栅栏处理完成之后，再进行后续的处理。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">dispatch_barrier_async(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</div><div class="line">    <span class="comment">// 根据图片和标识，生成图片信息类</span></div><div class="line">    AFCachedImage *cacheImage = [[AFCachedImage alloc] initWithImage:image identifier:identifier];</div><div class="line">    <span class="comment">// 根据标识查找是否已经存在对应的图片</span></div><div class="line">    AFCachedImage *previousCachedImage = <span class="keyword">self</span>.cachedImages[identifier];</div><div class="line">    <span class="comment">// 如果已经存在，先减少图片所占内存</span></div><div class="line">    <span class="keyword">if</span> (previousCachedImage != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.currentMemoryUsage -= previousCachedImage.totalBytes;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 再更新图片，和内存使用情况</span></div><div class="line">    <span class="keyword">self</span>.cachedImages[identifier] = cacheImage;</div><div class="line">    <span class="keyword">self</span>.currentMemoryUsage += cacheImage.totalBytes;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>如果内存满了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">dispatch_barrier_async(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.currentMemoryUsage &gt; <span class="keyword">self</span>.memoryCapacity) &#123;</div><div class="line">        <span class="comment">// 1. 需要清除的缓存大小</span></div><div class="line">        <span class="built_in">UInt64</span> bytesToPurge = <span class="keyword">self</span>.currentMemoryUsage - <span class="keyword">self</span>.preferredMemoryUsageAfterPurge;</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 先把可变字典里面所有的图片信息类放入数组，然后根据最新使用时间进行排序 </span></div><div class="line">        <span class="built_in">NSMutableArray</span> &lt;AFCachedImage*&gt; *sortedImages = [<span class="built_in">NSMutableArray</span> arrayWithArray:<span class="keyword">self</span>.cachedImages.allValues];</div><div class="line">        <span class="built_in">NSSortDescriptor</span> *sortDescriptor = [[<span class="built_in">NSSortDescriptor</span> alloc] initWithKey:<span class="string">@"lastAccessDate"</span> ascending:<span class="literal">YES</span>];</div><div class="line">        [sortedImages sortUsingDescriptors:@[sortDescriptor]];</div><div class="line"></div><div class="line">        <span class="comment">// 3. 默认已经清除的缓存</span></div><div class="line">        <span class="built_in">UInt64</span> bytesPurged = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 4. 一张张图片进行清除，然后更新已经清除的缓存容量，直到符合要求</span></div><div class="line">        <span class="keyword">for</span> (AFCachedImage *cachedImage <span class="keyword">in</span> sortedImages) &#123;</div><div class="line">            [<span class="keyword">self</span>.cachedImages removeObjectForKey:cachedImage.identifier];</div><div class="line">            bytesPurged += cachedImage.totalBytes;</div><div class="line">            <span class="keyword">if</span> (bytesPurged &gt;= bytesToPurge) &#123;</div><div class="line">                <span class="keyword">break</span> ;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 5. 更新当前内存已使用容量</span></div><div class="line">        <span class="keyword">self</span>.currentMemoryUsage -= bytesPurged;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong><em>1. AFNetwork中图片的缓存，自定义了一个对象<code>AFAutoPurgingImageCache</code>，在对象中声明了一个可变数组来进行图片的增删改查</em></strong></p>
<p><strong><em>2. AFAutoPurgingImageCache并没有磁盘缓存，也没有本地缓存，程序一旦重启，就需要重新进行缓存的处理</em></strong></p>
<p><strong><em>3. 源码阅读，要找到一个入口，静下心来看</em></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[记录Effective Objective-C 2.0 笔记目录]]></title>
      <url>http://lionwy.github.io/%E8%AE%B0%E5%BD%95Effective%20Objective-C%202.0%20%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Effective Objective-C 这本书只要认真看了的都会明白里面的东西有多重要</p>
</blockquote>
<ul>
<li>目前正在看第二遍，顺便写下自己的读书笔记，起个记录和提醒的作用，内容主要是简单总结，很少有例子，如果不清楚的，强烈建议看原书。当然对于电子书爱好者，<a href="https://pan.baidu.com/s/1gePb0Uv" target="_blank" rel="external">这里</a>分享下电子书版本。</li>
</ul>
<p><img src="http://oeb4c30x3.bkt.clouddn.com/download.jpg" alt=""></p>
<h1 id="第一章-熟悉Objective-C"><a href="#第一章-熟悉Objective-C" class="headerlink" title="第一章 熟悉Objective-C"></a>第一章 熟悉Objective-C</h1><blockquote>
<p>OC是在C语言的基础上添加了面向对象特性</p>
</blockquote>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/1.%E4%BA%86%E8%A7%A3Objective-C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B5%B7%E6%BA%90.md#%E4%BA%86%E8%A7%A3objective-c%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B5%B7%E6%BA%90" target="_blank" rel="external">1、Objective-C的起源、本质</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/2.%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%B0%BD%E9%87%8F%E5%B0%91%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E5%A4%B4%E6%96%87%E4%BB%B6.md#%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%B0%BD%E9%87%8F%E5%B0%91%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E5%A4%B4%E6%96%87%E4%BB%B6" target="_blank" rel="external">2、@class or import</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/3.%E5%A4%9A%E7%94%A8%E5%AD%97%E9%9D%A2%E9%87%8F%E8%AF%AD%E6%B3%95%EF%BC%8C%E5%B0%91%E7%94%A8%E4%B8%8E%E4%B9%8B%E7%AD%89%E4%BB%B7%E7%9A%84%E6%96%B9%E6%B3%95.md#%E5%A4%9A%E7%94%A8%E5%AD%97%E9%9D%A2%E9%87%8F%E8%AF%AD%E6%B3%95%E5%B0%91%E7%94%A8%E4%B8%8E%E4%B9%8B%E7%AD%89%E4%BB%B7%E7%9A%84%E6%96%B9%E6%B3%95" target="_blank" rel="external">3、使用<code>@</code>字面量语法</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/4.%E5%A4%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F%EF%BC%8C%E5%B0%91%E7%94%A8%23define%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.md#%E5%A4%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E5%B0%91%E7%94%A8define%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4" target="_blank" rel="external">4、如何使用宏define</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/5.%E7%94%A8%E6%9E%9A%E4%B8%BE%E8%A1%A8%E7%A4%BA%E7%8A%B6%E6%80%81%E3%80%81%E9%80%89%E9%A1%B9%E3%80%81%E7%8A%B6%E6%80%81%E7%A0%81.md#%E7%94%A8%E6%9E%9A%E4%B8%BE%E8%A1%A8%E7%A4%BA%E7%8A%B6%E6%80%81%E9%80%89%E9%A1%B9%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="external">5、枚举</a></p>
<h1 id="第二章-对象、消息、运行期"><a href="#第二章-对象、消息、运行期" class="headerlink" title="第二章 对象、消息、运行期"></a>第二章 对象、消息、运行期</h1><blockquote>
<ol>
<li>面向对象语言中，对象就是“基本构造单元”（building block），开发者通过对象来存储并传递数据。</li>
<li>对象之间传递数据并执行任务的过程就是“消息传递”（messaging）</li>
<li>运行期环境：就是开发者编写的代码，提供了一些使得对象之间能够传递消息的重要函数了，并且包含创建类实例所用的全部逻辑</li>
</ol>
</blockquote>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/6.%E7%90%86%E8%A7%A3%E2%80%9C%E5%B1%9E%E6%80%A7%E2%80%9D.md#%E7%90%86%E8%A7%A3%E5%B1%9E%E6%80%A7" target="_blank" rel="external">6、copy、strong属性</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/7.%E5%9C%A8%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E5%B0%BD%E9%87%8F%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F.md#%E5%9C%A8%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E5%B0%BD%E9%87%8F%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F" target="_blank" rel="external">7、<code>.</code>语法</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/8.%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%E7%AD%89%E5%90%8C%E6%80%A7.md#%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%E7%AD%89%E5%90%8C%E6%80%A7" target="_blank" rel="external">8、判断对象相等<code>=</code></a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/9.%E4%BB%A5%E7%B1%BB%E7%B0%87%E6%A8%A1%E5%BC%8F%E9%9A%90%E8%97%8F%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82.md#%E4%BB%A5%E7%B1%BB%E7%B0%87%E6%A8%A1%E5%BC%8F%E9%9A%90%E8%97%8F%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82" target="_blank" rel="external">9、类簇和工厂模式</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/10.%E5%9C%A8%E6%97%A2%E6%9C%89%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE.md#%E5%9C%A8%E6%97%A2%E6%9C%89%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE" target="_blank" rel="external">10、关联属性</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/11.%E7%90%86%E8%A7%A3objc_msgSend%E7%9A%84%E4%BD%9C%E7%94%A8.md#%E7%90%86%E8%A7%A3objc_msgsend%E7%9A%84%E4%BD%9C%E7%94%A8" target="_blank" rel="external">11、OC的消息发送</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/12.%E7%90%86%E8%A7%A3%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6.md#%E7%90%86%E8%A7%A3%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91" target="_blank" rel="external">12、消息转发</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/13.%E7%94%A8%E6%96%B9%E6%B3%95%E8%B0%83%E9%85%8D%E6%8A%80%E6%9C%AF%E8%B0%83%E8%AF%95%E9%BB%91%E7%9B%92%E6%96%B9%E6%B3%95.md#%E7%94%A8%E6%96%B9%E6%B3%95%E8%B0%83%E9%85%8D%E6%8A%80%E6%9C%AF%E8%B0%83%E8%AF%95%E9%BB%91%E7%9B%92%E6%96%B9%E6%B3%95" target="_blank" rel="external">13、黑魔法method swizzling</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/14.%E7%90%86%E8%A7%A3%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%A8%E6%84%8F.md#%E7%90%86%E8%A7%A3%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%A8%E6%84%8F" target="_blank" rel="external">14、OC对象</a></p>
<h1 id="第三章-接口与API设计"><a href="#第三章-接口与API设计" class="headerlink" title="第三章 接口与API设计"></a>第三章 接口与API设计</h1><blockquote>
<p>如果要重用代码，就需要在编写接口的时候将其设计成易于复用的形式，包括命名、编码规范等。</p>
</blockquote>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/15.%E7%94%A8%E5%89%8D%E7%BC%80%E9%81%BF%E5%85%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%86%B2%E7%AA%81.md#%E7%94%A8%E5%89%8D%E7%BC%80%E9%81%BF%E5%85%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%86%B2%E7%AA%81" target="_blank" rel="external">15、命名前缀</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/16.%E6%8F%90%E4%BE%9B%E5%85%A8%E8%83%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95.md#%E6%8F%90%E4%BE%9B%E5%85%A8%E8%83%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95" target="_blank" rel="external">16、init</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/17.%E5%AE%9E%E7%8E%B0description%E6%96%B9%E6%B3%95.md#%E5%AE%9E%E7%8E%B0description%E6%96%B9%E6%B3%95" target="_blank" rel="external">17、description</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/18.%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1.md#%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1" target="_blank" rel="external">18、readonly</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/19.%E4%BD%BF%E7%94%A8%E6%B8%85%E6%99%B0%E8%80%8C%E5%8D%8F%E8%B0%83%E7%9A%84%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F.md#%E4%BD%BF%E7%94%A8%E6%B8%85%E6%99%B0%E8%80%8C%E5%8D%8F%E8%B0%83%E7%9A%84%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F" target="_blank" rel="external">19、怎么起名字</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/20.%E4%B8%BA%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%90%8D%E5%8A%A0%E5%89%8D%E7%BC%80.md#%E4%B8%BA%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%90%8D%E5%8A%A0%E5%89%8D%E7%BC%80" target="_blank" rel="external">20、私有方法</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/21.%E7%90%86%E8%A7%A3Objective-C%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B.md#%E7%90%86%E8%A7%A3oc%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B" target="_blank" rel="external">21、异常和error</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/22.%E7%90%86%E8%A7%A3NSCoping%E5%8D%8F%E8%AE%AE.md#%E7%90%86%E8%A7%A3nscoping%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">22、copy 是浅拷贝还是很拷贝</a></p>
<h1 id="第四章-协议与分类"><a href="#第四章-协议与分类" class="headerlink" title="第四章 协议与分类"></a>第四章 协议与分类</h1><blockquote>
<p>OC不支持多重继承（继承不同的类），因此我们把某个类应该实现的一系列方法定义在协议里面。<br>OC运行期系统是高度动态的，因此可以利用分类，无需继承子类即可直接为当前类添加方法。</p>
</blockquote>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/23.%E9%80%9A%E8%BF%87%E5%A7%94%E6%89%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E9%97%B4%E9%80%9A%E4%BF%A1.md#%E9%80%9A%E8%BF%87%E5%A7%94%E6%89%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E9%97%B4%E9%80%9A%E4%BF%A1" target="_blank" rel="external">23、协议 delegate</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/24-27%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%9F%E8%83%BD.md#24-%E5%B0%86%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E5%88%86%E6%95%A3%E5%88%B0%E4%BE%BF%E4%BA%8E%E7%AE%A1%E7%90%86%E7%9A%84%E6%95%B0%E4%B8%AA%E5%88%86%E7%B1%BB%E4%B9%8B%E4%B8%AD" target="_blank" rel="external">24-27、用好分类category</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/28.%E9%80%9A%E8%BF%87%E5%8D%8F%E8%AE%AE%E6%8F%90%E4%BE%9B%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1.md#%E9%80%9A%E8%BF%87%E5%8D%8F%E8%AE%AE%E6%8F%90%E4%BE%9B%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1" target="_blank" rel="external">28、<code>id</code>匿名对象</a></p>
<h1 id="第五章-内存管理"><a href="#第五章-内存管理" class="headerlink" title="第五章 内存管理"></a>第五章 内存管理</h1><p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/29%E3%80%8136.%E7%90%86%E8%A7%A3%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.md#%E7%90%86%E8%A7%A3%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0" target="_blank" rel="external">29、36、向<code>retainCount</code>say NO</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/30.%E4%BB%A5ARC%E7%AE%80%E5%8C%96%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.md#%E4%BB%A5arc%E7%AE%80%E5%8C%96%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0" target="_blank" rel="external">30、什么是ARC</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/31.%E5%9C%A8dealloc%E4%B8%AD%E5%8F%AA%E9%87%8A%E6%94%BE%E5%BC%95%E7%94%A8%E5%B9%B6%E8%A7%A3%E9%99%A4%E7%9B%91%E5%90%AC.md#%E5%9C%A8dealloc%E4%B8%AD%E5%8F%AA%E9%87%8A%E6%94%BE%E5%BC%95%E7%94%A8%E5%B9%B6%E8%A7%A3%E9%99%A4%E7%9B%91%E5%90%AC" target="_blank" rel="external">31、<code>dealloc</code>里面干什么</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/33.%E4%BB%A5%E5%BC%B1%E5%BC%95%E7%94%A8%E9%81%BF%E5%85%8D%E4%BF%9D%E7%95%99%E7%8E%AF.md#%E4%BB%A5%E5%BC%B1%E5%BC%95%E7%94%A8%E9%81%BF%E5%85%8D%E4%BF%9D%E7%95%99%E7%8E%AF" target="_blank" rel="external">33、循环引用的解决方案</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/34.%E4%BB%A5%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E5%9D%97%E9%99%8D%E4%BD%8E%E5%86%85%E5%AD%98%E5%B3%B0%E5%80%BC.md#%E4%BB%A5%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E9%99%8D%E4%BD%8E%E5%86%85%E5%AD%98%E5%B3%B0%E5%80%BC" target="_blank" rel="external">34、简单了解下@autoreleasepool</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/35.%E7%94%A8%E5%83%B5%E5%B0%B8%E5%AF%B9%E8%B1%A1%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98.md#%E7%94%A8%E5%83%B5%E5%B0%B8%E5%AF%B9%E8%B1%A1%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98" target="_blank" rel="external">35、僵尸对象到底是什么</a></p>
<h1 id="第六章-块与大中枢派发"><a href="#第六章-块与大中枢派发" class="headerlink" title="第六章 块与大中枢派发"></a>第六章 块与大中枢派发</h1><blockquote>
<ul>
<li>块（block）是一种可在C、C++及OC代码中使用的词法闭包，借由块，开发者可将代码像对象一样传递。</li>
<li>GCD提供了对线程的抽象，这种抽象基于“派发队列”（dispatch queue）。GCD会根据系统资源情况，适时地创建、复用、摧毁后台线程，以便处理每个队列。</li>
</ul>
</blockquote>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/37.%E7%90%86%E8%A7%A3%E5%9D%97%E7%9A%84%E6%A6%82%E5%BF%B5.md#%E7%90%86%E8%A7%A3%E5%9D%97%E7%9A%84%E6%A6%82%E5%BF%B5" target="_blank" rel="external">37、block概念</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/38.%E4%B8%BA%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9D%97%E7%B1%BB%E5%9E%8B%E5%88%9B%E5%BB%BAtypedef.md#%E4%B8%BA%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9D%97%E7%B1%BB%E5%9E%8B%E5%88%9B%E5%BB%BAtypedef" target="_blank" rel="external">38、声明block</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/39.%E7%94%A8handler%E5%9D%97%E9%99%8D%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%88%86%E6%95%A3%E7%A8%8B%E5%BA%A6.md#%E7%94%A8handler%E5%9D%97%E9%99%8D%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%88%86%E6%95%A3%E7%A8%8B%E5%BA%A6" target="_blank" rel="external">39、block or delegate</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/41.%E5%A4%9A%E7%94%A8%E6%B4%BE%E5%8F%91%E9%98%9F%E5%88%97%EF%BC%8C%E5%B0%91%E7%94%A8%E5%90%8C%E6%AD%A5%E9%94%81.md#%E5%A4%9A%E7%94%A8%E6%B4%BE%E5%8F%91%E9%98%9F%E5%88%97%E5%B0%91%E7%94%A8%E5%90%8C%E6%AD%A5%E9%94%81" target="_blank" rel="external">41、iOS中的锁</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/42.%E5%A4%9A%E7%94%A8GCD%EF%BC%8C%E5%B0%91%E7%94%A8performSelector%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95.md#%E5%A4%9A%E7%94%A8gcd%E5%B0%91%E7%94%A8performselector%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95" target="_blank" rel="external">42、GCD 取代 performSelector
</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/43.%E6%8E%8C%E6%8F%A1GCD%E5%8F%8A%E6%93%8D%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA.md#%E6%8E%8C%E6%8F%A1gcd%E5%8F%8A%E6%93%8D%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA" target="_blank" rel="external">43、NSOperation</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/44.%E9%80%9A%E8%BF%87Dispatch%20Group%20%E6%9C%BA%E5%88%B6%EF%BC%8C%E6%A0%B9%E6%8D%AE%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E7%8A%B6%E5%86%B5%E6%9D%A5%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1.md#%E9%80%9A%E8%BF%87dispatch-group%E6%9C%BA%E5%88%B6%E6%A0%B9%E6%8D%AE%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E7%8A%B6%E5%86%B5%E6%9D%A5%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1" target="_blank" rel="external">44、dispatch group 的方法简介</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/45.%E4%BD%BF%E7%94%A8dispatch_once%E6%9D%A5%E6%89%A7%E8%A1%8C%E5%8F%AA%E9%9C%80%E8%BF%90%E8%A1%8C%E4%B8%80%E6%AC%A1%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81.md#%E4%BD%BF%E7%94%A8dispatch_once%E6%9D%A5%E6%89%A7%E8%A1%8C%E5%8F%AA%E9%9C%80%E8%BF%90%E8%A1%8C%E4%B8%80%E6%AC%A1%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81" target="_blank" rel="external">45、dispatch_once 实现单例</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/46.%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8dispatch_get_current_queue.md#%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8dispatch_get_current_queue" target="_blank" rel="external">46、废弃的dispatch_get_current_queue
</a></p>
<h1 id="第七章-系统框架"><a href="#第七章-系统框架" class="headerlink" title="第七章 系统框架"></a>第七章 系统框架</h1><blockquote>
<p>只要编写OC代码，就离不开系统框架</p>
</blockquote>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/47.%E7%86%9F%E6%82%89%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6.md#%E7%86%9F%E6%82%89%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6" target="_blank" rel="external">47、熟悉系统框架</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/48.%E5%A4%9A%E7%94%A8%E5%9D%97%E6%9E%9A%E4%B8%BE%EF%BC%8C%E5%B0%91%E7%94%A8for%E5%BE%AA%E7%8E%AF.md#%E5%A4%9A%E7%94%A8%E5%9D%97%E6%9E%9A%E4%B8%BE%E5%B0%91%E7%94%A8for%E5%BE%AA%E7%8E%AF" target="_blank" rel="external">48、四个遍历方法</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/49.%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%B6%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%AD%E4%B9%89%E7%9A%84collection%E4%BD%BF%E7%94%A8%E6%97%A0%E7%BC%9D%E6%A1%A5%E6%8E%A5.md#%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%B6%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%AD%E4%B9%89%E7%9A%84collection%E4%BD%BF%E7%94%A8%E6%97%A0%E7%BC%9D%E6%A1%A5%E6%8E%A5" target="_blank" rel="external">49、使用__bridge无缝桥接</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/50.%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98%E6%97%B6%E9%80%89%E7%94%A8NSCache%E8%80%8C%E9%9D%9ENSDictionary.md#%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98%E6%97%B6%E9%80%89%E7%94%A8nscache%E8%80%8C%E9%9D%9Ensdictionary" target="_blank" rel="external">50、缓存NSCache</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/51.%E7%B2%BE%E7%AE%80initialize%E4%B8%8Eload%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81.md#%E7%B2%BE%E7%AE%80initialize%E4%B8%8Eload%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81" target="_blank" rel="external">51、你应该了解的initialize与load</a></p>
<p><a href="https://github.com/LionWY/Read_Notes/blob/master/Effective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/52.%E5%88%AB%E5%BF%98%E4%BA%86NSTimer%E4%BC%9A%E4%BF%9D%E7%95%99%E5%85%B6%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1.md#%E5%88%AB%E5%BF%98%E4%BA%86nstimer%E4%BC%9A%E4%BF%9D%E7%95%99%E5%85%B6%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1" target="_blank" rel="external">52、NSTimer的小知识</a></p>
<p>[终]</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 常用命令]]></title>
      <url>http://lionwy.github.io/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="Hexo-常用命令"><a href="#Hexo-常用命令" class="headerlink" title="Hexo 常用命令"></a>Hexo 常用命令</h1><blockquote>
<p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">官方文档</a></p>
</blockquote>
<ol>
<li><p>把本地文件上传blog</p>
<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre></li>
<li><p>新建文章</p>
<pre><code>hexo new “文章题目”
</code></pre></li>
<li><p>新建另一页（如关于，标签，分类）</p>
<pre><code>hexo new page &quot;about&quot;
</code></pre></li>
<li><p>分类下显示你所编写的标签</p>
<pre><code>---
title: categories
date: 2016-09-14 11:54:11
type: &quot;categories&quot; #这句话不能少
comments: false   #去除多说评论框

---
</code></pre></li>
<li><p>添加多说评论</p>
<ul>
<li><p><a href="http://duoshuo.com/" target="_blank" rel="external">多说官网</a> “我要安装”</p>
</li>
<li><p>在 next 主题设置shortName</p>
<pre><code># Duoshuo ShortName #不能去掉注释 
duoshuo_shortname: your_short_name
</code></pre></li>
</ul>
</li>
<li><p>文章添加多个标签</p>
<pre><code>tags: [tag1,tag2,tag3] #冒号后面添加空格
</code></pre></li>
<li><p>关于标题设置</p>
<pre><code>~/Hexo/themes/next/layout/index.swig 
</code></pre></li>
</ol>
<figure class="highlight django"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="comment">&lt;!--设置的标题 + 主题的描述--&gt;</span></span></div><div class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> </span><span class="template-variable">&#123;&#123; config.title &#125;&#125;</span><span class="xml"> - </span><span class="template-variable">&#123;&#123; theme.description &#125;&#125;</span><span class="xml"> </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></div><div class="line">		</div><div class="line"><span class="comment">&lt;!--主题关键字 + 标题 + 主题描述--&gt;</span>		</div><div class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> </span><span class="template-variable">&#123;&#123; theme.keywords &#125;&#125;</span><span class="xml"> - </span><span class="template-variable">&#123;&#123; config.title &#125;&#125;</span><span class="xml"> - </span><span class="template-variable">&#123;&#123; theme.description &#125;&#125;</span><span class="xml"> </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></div><div class="line">		</div><div class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> </span><span class="template-variable">&#123;&#123; config.title &#125;&#125;</span><span class="xml"> </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
